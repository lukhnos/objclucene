//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/util/ArrayUtil.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneUtilArrayUtil")
#ifdef RESTRICT_OrgApacheLuceneUtilArrayUtil
#define INCLUDE_ALL_OrgApacheLuceneUtilArrayUtil 0
#else
#define INCLUDE_ALL_OrgApacheLuceneUtilArrayUtil 1
#endif
#undef RESTRICT_OrgApacheLuceneUtilArrayUtil

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheLuceneUtilArrayUtil_) && (INCLUDE_ALL_OrgApacheLuceneUtilArrayUtil || defined(INCLUDE_OrgApacheLuceneUtilArrayUtil))
#define OrgApacheLuceneUtilArrayUtil_

@class IOSBooleanArray;
@class IOSByteArray;
@class IOSCharArray;
@class IOSDoubleArray;
@class IOSFloatArray;
@class IOSIntArray;
@class IOSLongArray;
@class IOSObjectArray;
@class IOSShortArray;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;

/*!
 @brief Methods for manipulating arrays.
 */
@interface OrgApacheLuceneUtilArrayUtil : NSObject
@property (readonly, class) jint MAX_ARRAY_LENGTH NS_SWIFT_NAME(MAX_ARRAY_LENGTH);

#pragma mark Public

/*!
 @brief See if two array slices are the same.
 @param left The left array to compare
 @param offsetLeft The offset into the array.  Must be positive
 @param right The right array to compare
 @param offsetRight the offset into the right array.  Must be positive
 @param length The length of the section of the array to compare
 @return true if the two arrays, starting at their respective offsets, are equal
 - seealso: java.util.Arrays#equals(byte[], byte[])
 */
+ (jboolean)equalsWithByteArray:(IOSByteArray *)left
                        withInt:(jint)offsetLeft
                  withByteArray:(IOSByteArray *)right
                        withInt:(jint)offsetRight
                        withInt:(jint)length;

/*!
 @brief See if two array slices are the same.
 @param left The left array to compare
 @param offsetLeft The offset into the array.  Must be positive
 @param right The right array to compare
 @param offsetRight the offset into the right array.  Must be positive
 @param length The length of the section of the array to compare
 @return true if the two arrays, starting at their respective offsets, are equal
 - seealso: java.util.Arrays#equals(char[], char[])
 */
+ (jboolean)equalsWithCharArray:(IOSCharArray *)left
                        withInt:(jint)offsetLeft
                  withCharArray:(IOSCharArray *)right
                        withInt:(jint)offsetRight
                        withInt:(jint)length;

/*!
 @brief See if two array slices are the same.
 @param left The left array to compare
 @param offsetLeft The offset into the array.  Must be positive
 @param right The right array to compare
 @param offsetRight the offset into the right array.  Must be positive
 @param length The length of the section of the array to compare
 @return true if the two arrays, starting at their respective offsets, are equal
 - seealso: java.util.Arrays#equals(char[], char[])
 */
+ (jboolean)equalsWithIntArray:(IOSIntArray *)left
                       withInt:(jint)offsetLeft
                  withIntArray:(IOSIntArray *)right
                       withInt:(jint)offsetRight
                       withInt:(jint)length;

+ (jint)getShrinkSizeWithInt:(jint)currentSize
                     withInt:(jint)targetSize
                     withInt:(jint)bytesPerElement;

+ (IOSBooleanArray *)growWithBooleanArray:(IOSBooleanArray *)array;

+ (IOSBooleanArray *)growWithBooleanArray:(IOSBooleanArray *)array
                                  withInt:(jint)minSize;

+ (IOSByteArray *)growWithByteArray:(IOSByteArray *)array;

+ (IOSByteArray *)growWithByteArray:(IOSByteArray *)array
                            withInt:(jint)minSize;

+ (IOSCharArray *)growWithCharArray:(IOSCharArray *)array;

+ (IOSCharArray *)growWithCharArray:(IOSCharArray *)array
                            withInt:(jint)minSize;

+ (IOSDoubleArray *)growWithDoubleArray:(IOSDoubleArray *)array;

+ (IOSDoubleArray *)growWithDoubleArray:(IOSDoubleArray *)array
                                withInt:(jint)minSize;

+ (IOSFloatArray *)growWithFloatArray:(IOSFloatArray *)array;

+ (IOSFloatArray *)growWithFloatArray:(IOSFloatArray *)array
                              withInt:(jint)minSize;

+ (IOSObjectArray *)growWithFloatArray2:(IOSObjectArray *)array;

+ (IOSObjectArray *)growWithFloatArray2:(IOSObjectArray *)array
                                withInt:(jint)minSize;

+ (IOSIntArray *)growWithIntArray:(IOSIntArray *)array;

+ (IOSIntArray *)growWithIntArray:(IOSIntArray *)array
                          withInt:(jint)minSize;

+ (IOSObjectArray *)growWithIntArray2:(IOSObjectArray *)array;

+ (IOSObjectArray *)growWithIntArray2:(IOSObjectArray *)array
                              withInt:(jint)minSize;

+ (IOSLongArray *)growWithLongArray:(IOSLongArray *)array;

+ (IOSLongArray *)growWithLongArray:(IOSLongArray *)array
                            withInt:(jint)minSize;

+ (IOSShortArray *)growWithShortArray:(IOSShortArray *)array;

+ (IOSShortArray *)growWithShortArray:(IOSShortArray *)array
                              withInt:(jint)minSize;

+ (IOSObjectArray *)growWithNSObjectArray:(IOSObjectArray *)array
                                  withInt:(jint)minSize;

/*!
 @brief Returns hash of bytes in range start (inclusive) to
  end (inclusive)
 */
+ (jint)hashCodeWithByteArray:(IOSByteArray *)array
                      withInt:(jint)start
                      withInt:(jint)end;

/*!
 @brief Returns hash of chars in range start (inclusive) to
  end (inclusive)
 */
+ (jint)hashCodeWithCharArray:(IOSCharArray *)array
                      withInt:(jint)start
                      withInt:(jint)end;

/*!
 @brief Sorts the given array in natural order.This method uses the intro sort
  algorithm, but falls back to insertion sort for small arrays.
 */
+ (void)introSortWithJavaLangComparableArray:(IOSObjectArray *)a;

/*!
 @brief Sorts the given array using the <code>Comparator</code>.This method uses the intro sort
  algorithm, but falls back to insertion sort for small arrays.
 */
+ (void)introSortWithNSObjectArray:(IOSObjectArray *)a
            withJavaUtilComparator:(id<JavaUtilComparator>)comp;

/*!
 @brief Sorts the given array slice in natural order.This method uses the intro sort
  algorithm, but falls back to insertion sort for small arrays.
 @param fromIndex start index (inclusive)
 @param toIndex end index (exclusive)
 */
+ (void)introSortWithJavaLangComparableArray:(IOSObjectArray *)a
                                     withInt:(jint)fromIndex
                                     withInt:(jint)toIndex;

/*!
 @brief Sorts the given array slice using the <code>Comparator</code>.This method uses the intro sort
  algorithm, but falls back to insertion sort for small arrays.
 @param fromIndex start index (inclusive)
 @param toIndex end index (exclusive)
 */
+ (void)introSortWithNSObjectArray:(IOSObjectArray *)a
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex
            withJavaUtilComparator:(id<JavaUtilComparator>)comp;

/*!
 @brief Get the natural <code>Comparator</code> for the provided object class.
 */
+ (id<JavaUtilComparator>)naturalComparator;

/*!
 @brief Returns an array size &gt;= minTargetSize, generally
   over-allocating exponentially to achieve amortized
   linear-time cost as the array grows.
 NOTE: this was originally borrowed from Python 2.4.2
   listobject.c sources (attribution in LICENSE.txt), but
   has now been substantially changed based on
   discussions from java-dev thread with subject "Dynamic
   array reallocation algorithms", started on Jan 12
   2010.
 @param minTargetSize Minimum required value to be returned.
 @param bytesPerElement Bytes used by each element of  the array.  See constants in 
 <code>RamUsageEstimator</code> .
 */
+ (jint)oversizeWithInt:(jint)minTargetSize
                withInt:(jint)bytesPerElement;

/*!
 @brief Parses the string argument as if it was an int value and returns the
  result.Throws NumberFormatException if the string does not represent an
  int quantity.
 @param chars a string representation of an int quantity.
 @return int the value represented by the argument
 @throw NumberFormatExceptionif the argument could not be parsed as an int quantity.
 */
+ (jint)parseIntWithCharArray:(IOSCharArray *)chars;

/*!
 @brief Parses a char array into an int.
 @param chars the character array
 @param offset The offset into the array
 @param len The length
 @return the int
 @throw NumberFormatExceptionif it can't parse
 */
+ (jint)parseIntWithCharArray:(IOSCharArray *)chars
                      withInt:(jint)offset
                      withInt:(jint)len;

/*!
 @brief Parses the string argument as if it was an int value and returns the
  result.Throws NumberFormatException if the string does not represent an
  int quantity.
 The second argument specifies the radix to use when parsing
  the value.
 @param chars a string representation of an int quantity.
 @param radix the base to use for conversion.
 @return int the value represented by the argument
 @throw NumberFormatExceptionif the argument could not be parsed as an int quantity.
 */
+ (jint)parseIntWithCharArray:(IOSCharArray *)chars
                      withInt:(jint)offset
                      withInt:(jint)len
                      withInt:(jint)radix;

+ (IOSBooleanArray *)shrinkWithBooleanArray:(IOSBooleanArray *)array
                                    withInt:(jint)targetSize;

+ (IOSByteArray *)shrinkWithByteArray:(IOSByteArray *)array
                              withInt:(jint)targetSize;

+ (IOSCharArray *)shrinkWithCharArray:(IOSCharArray *)array
                              withInt:(jint)targetSize;

+ (IOSObjectArray *)shrinkWithFloatArray2:(IOSObjectArray *)array
                                  withInt:(jint)targetSize;

+ (IOSIntArray *)shrinkWithIntArray:(IOSIntArray *)array
                            withInt:(jint)targetSize;

+ (IOSObjectArray *)shrinkWithIntArray2:(IOSObjectArray *)array
                                withInt:(jint)targetSize;

+ (IOSLongArray *)shrinkWithLongArray:(IOSLongArray *)array
                              withInt:(jint)targetSize;

+ (IOSShortArray *)shrinkWithShortArray:(IOSShortArray *)array
                                withInt:(jint)targetSize;

/*!
 @brief Swap values stored in slots <code>i</code> and <code>j</code>
 */
+ (void)swapWithNSObjectArray:(IOSObjectArray *)arr
                      withInt:(jint)i
                      withInt:(jint)j;

/*!
 @brief Sorts the given array in natural order.This method uses the Tim sort
  algorithm, but falls back to binary sort for small arrays.
 */
+ (void)timSortWithJavaLangComparableArray:(IOSObjectArray *)a;

/*!
 @brief Sorts the given array using the <code>Comparator</code>.This method uses the Tim sort
  algorithm, but falls back to binary sort for small arrays.
 */
+ (void)timSortWithNSObjectArray:(IOSObjectArray *)a
          withJavaUtilComparator:(id<JavaUtilComparator>)comp;

/*!
 @brief Sorts the given array slice in natural order.This method uses the Tim sort
  algorithm, but falls back to binary sort for small arrays.
 @param fromIndex start index (inclusive)
 @param toIndex end index (exclusive)
 */
+ (void)timSortWithJavaLangComparableArray:(IOSObjectArray *)a
                                   withInt:(jint)fromIndex
                                   withInt:(jint)toIndex;

/*!
 @brief Sorts the given array slice using the <code>Comparator</code>.This method uses the Tim sort
  algorithm, but falls back to binary sort for small arrays.
 @param fromIndex start index (inclusive)
 @param toIndex end index (exclusive)
 */
+ (void)timSortWithNSObjectArray:(IOSObjectArray *)a
                         withInt:(jint)fromIndex
                         withInt:(jint)toIndex
          withJavaUtilComparator:(id<JavaUtilComparator>)comp;

+ (IOSIntArray *)toIntArrayWithJavaUtilCollection:(id<JavaUtilCollection>)ints;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneUtilArrayUtil)

/*!
 @brief Maximum length for an array (Integer.MAX_VALUE - RamUsageEstimator.NUM_BYTES_ARRAY_HEADER).
 */
inline jint OrgApacheLuceneUtilArrayUtil_get_MAX_ARRAY_LENGTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_MAX_ARRAY_LENGTH;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(OrgApacheLuceneUtilArrayUtil, MAX_ARRAY_LENGTH, jint)

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_parseIntWithCharArray_(IOSCharArray *chars);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_parseIntWithCharArray_withInt_withInt_(IOSCharArray *chars, jint offset, jint len);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_parseIntWithCharArray_withInt_withInt_withInt_(IOSCharArray *chars, jint offset, jint len, jint radix);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_oversizeWithInt_withInt_(jint minTargetSize, jint bytesPerElement);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_getShrinkSizeWithInt_withInt_withInt_(jint currentSize, jint targetSize, jint bytesPerElement);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_growWithNSObjectArray_withInt_(IOSObjectArray *array, jint minSize);

FOUNDATION_EXPORT IOSShortArray *OrgApacheLuceneUtilArrayUtil_growWithShortArray_withInt_(IOSShortArray *array, jint minSize);

FOUNDATION_EXPORT IOSShortArray *OrgApacheLuceneUtilArrayUtil_growWithShortArray_(IOSShortArray *array);

FOUNDATION_EXPORT IOSFloatArray *OrgApacheLuceneUtilArrayUtil_growWithFloatArray_withInt_(IOSFloatArray *array, jint minSize);

FOUNDATION_EXPORT IOSFloatArray *OrgApacheLuceneUtilArrayUtil_growWithFloatArray_(IOSFloatArray *array);

FOUNDATION_EXPORT IOSDoubleArray *OrgApacheLuceneUtilArrayUtil_growWithDoubleArray_withInt_(IOSDoubleArray *array, jint minSize);

FOUNDATION_EXPORT IOSDoubleArray *OrgApacheLuceneUtilArrayUtil_growWithDoubleArray_(IOSDoubleArray *array);

FOUNDATION_EXPORT IOSShortArray *OrgApacheLuceneUtilArrayUtil_shrinkWithShortArray_withInt_(IOSShortArray *array, jint targetSize);

FOUNDATION_EXPORT IOSIntArray *OrgApacheLuceneUtilArrayUtil_growWithIntArray_withInt_(IOSIntArray *array, jint minSize);

FOUNDATION_EXPORT IOSIntArray *OrgApacheLuceneUtilArrayUtil_growWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT IOSIntArray *OrgApacheLuceneUtilArrayUtil_shrinkWithIntArray_withInt_(IOSIntArray *array, jint targetSize);

FOUNDATION_EXPORT IOSLongArray *OrgApacheLuceneUtilArrayUtil_growWithLongArray_withInt_(IOSLongArray *array, jint minSize);

FOUNDATION_EXPORT IOSLongArray *OrgApacheLuceneUtilArrayUtil_growWithLongArray_(IOSLongArray *array);

FOUNDATION_EXPORT IOSLongArray *OrgApacheLuceneUtilArrayUtil_shrinkWithLongArray_withInt_(IOSLongArray *array, jint targetSize);

FOUNDATION_EXPORT IOSByteArray *OrgApacheLuceneUtilArrayUtil_growWithByteArray_withInt_(IOSByteArray *array, jint minSize);

FOUNDATION_EXPORT IOSByteArray *OrgApacheLuceneUtilArrayUtil_growWithByteArray_(IOSByteArray *array);

FOUNDATION_EXPORT IOSByteArray *OrgApacheLuceneUtilArrayUtil_shrinkWithByteArray_withInt_(IOSByteArray *array, jint targetSize);

FOUNDATION_EXPORT IOSBooleanArray *OrgApacheLuceneUtilArrayUtil_growWithBooleanArray_withInt_(IOSBooleanArray *array, jint minSize);

FOUNDATION_EXPORT IOSBooleanArray *OrgApacheLuceneUtilArrayUtil_growWithBooleanArray_(IOSBooleanArray *array);

FOUNDATION_EXPORT IOSBooleanArray *OrgApacheLuceneUtilArrayUtil_shrinkWithBooleanArray_withInt_(IOSBooleanArray *array, jint targetSize);

FOUNDATION_EXPORT IOSCharArray *OrgApacheLuceneUtilArrayUtil_growWithCharArray_withInt_(IOSCharArray *array, jint minSize);

FOUNDATION_EXPORT IOSCharArray *OrgApacheLuceneUtilArrayUtil_growWithCharArray_(IOSCharArray *array);

FOUNDATION_EXPORT IOSCharArray *OrgApacheLuceneUtilArrayUtil_shrinkWithCharArray_withInt_(IOSCharArray *array, jint targetSize);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_growWithIntArray2_withInt_(IOSObjectArray *array, jint minSize);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_growWithIntArray2_(IOSObjectArray *array);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_shrinkWithIntArray2_withInt_(IOSObjectArray *array, jint targetSize);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_growWithFloatArray2_withInt_(IOSObjectArray *array, jint minSize);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_growWithFloatArray2_(IOSObjectArray *array);

FOUNDATION_EXPORT IOSObjectArray *OrgApacheLuceneUtilArrayUtil_shrinkWithFloatArray2_withInt_(IOSObjectArray *array, jint targetSize);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_hashCodeWithCharArray_withInt_withInt_(IOSCharArray *array, jint start, jint end);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilArrayUtil_hashCodeWithByteArray_withInt_withInt_(IOSByteArray *array, jint start, jint end);

FOUNDATION_EXPORT jboolean OrgApacheLuceneUtilArrayUtil_equalsWithCharArray_withInt_withCharArray_withInt_withInt_(IOSCharArray *left, jint offsetLeft, IOSCharArray *right, jint offsetRight, jint length);

FOUNDATION_EXPORT jboolean OrgApacheLuceneUtilArrayUtil_equalsWithByteArray_withInt_withByteArray_withInt_withInt_(IOSByteArray *left, jint offsetLeft, IOSByteArray *right, jint offsetRight, jint length);

FOUNDATION_EXPORT jboolean OrgApacheLuceneUtilArrayUtil_equalsWithIntArray_withInt_withIntArray_withInt_withInt_(IOSIntArray *left, jint offsetLeft, IOSIntArray *right, jint offsetRight, jint length);

FOUNDATION_EXPORT IOSIntArray *OrgApacheLuceneUtilArrayUtil_toIntArrayWithJavaUtilCollection_(id<JavaUtilCollection> ints);

FOUNDATION_EXPORT id<JavaUtilComparator> OrgApacheLuceneUtilArrayUtil_naturalComparator(void);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_swapWithNSObjectArray_withInt_withInt_(IOSObjectArray *arr, jint i, jint j);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_introSortWithNSObjectArray_withInt_withInt_withJavaUtilComparator_(IOSObjectArray *a, jint fromIndex, jint toIndex, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_introSortWithNSObjectArray_withJavaUtilComparator_(IOSObjectArray *a, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_introSortWithJavaLangComparableArray_withInt_withInt_(IOSObjectArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_introSortWithJavaLangComparableArray_(IOSObjectArray *a);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_timSortWithNSObjectArray_withInt_withInt_withJavaUtilComparator_(IOSObjectArray *a, jint fromIndex, jint toIndex, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_timSortWithNSObjectArray_withJavaUtilComparator_(IOSObjectArray *a, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_timSortWithJavaLangComparableArray_withInt_withInt_(IOSObjectArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void OrgApacheLuceneUtilArrayUtil_timSortWithJavaLangComparableArray_(IOSObjectArray *a);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneUtilArrayUtil)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneUtilArrayUtil")
