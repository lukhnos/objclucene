//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/util/UnicodeUtil.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneUtilUnicodeUtil")
#ifdef RESTRICT_OrgApacheLuceneUtilUnicodeUtil
#define INCLUDE_ALL_OrgApacheLuceneUtilUnicodeUtil 0
#else
#define INCLUDE_ALL_OrgApacheLuceneUtilUnicodeUtil 1
#endif
#undef RESTRICT_OrgApacheLuceneUtilUnicodeUtil

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheLuceneUtilUnicodeUtil_) && (INCLUDE_ALL_OrgApacheLuceneUtilUnicodeUtil || defined(INCLUDE_OrgApacheLuceneUtilUnicodeUtil))
#define OrgApacheLuceneUtilUnicodeUtil_

@class IOSByteArray;
@class IOSCharArray;
@class IOSIntArray;
@class OrgApacheLuceneUtilBytesRef;
@protocol JavaLangCharSequence;

/*!
 @brief Class to encode java's UTF16 char[] into UTF8 byte[]
  without always allocating a new byte[] as
  String.getBytes(StandardCharsets.UTF_8) does.
 */
@interface OrgApacheLuceneUtilUnicodeUtil : NSObject
@property (readonly, class, strong) OrgApacheLuceneUtilBytesRef *BIG_TERM NS_SWIFT_NAME(BIG_TERM);
@property (readonly, class) jint UNI_SUR_HIGH_START NS_SWIFT_NAME(UNI_SUR_HIGH_START);
@property (readonly, class) jint UNI_SUR_HIGH_END NS_SWIFT_NAME(UNI_SUR_HIGH_END);
@property (readonly, class) jint UNI_SUR_LOW_START NS_SWIFT_NAME(UNI_SUR_LOW_START);
@property (readonly, class) jint UNI_SUR_LOW_END NS_SWIFT_NAME(UNI_SUR_LOW_END);
@property (readonly, class) jint UNI_REPLACEMENT_CHAR NS_SWIFT_NAME(UNI_REPLACEMENT_CHAR);
@property (readonly, class) jint MAX_UTF8_BYTES_PER_CHAR NS_SWIFT_NAME(MAX_UTF8_BYTES_PER_CHAR);
@property (readonly, class, strong) IOSIntArray *utf8CodeLength NS_SWIFT_NAME(utf8CodeLength);

#pragma mark Public

/*!
 @brief Returns the number of code points in this UTF8 sequence.
 <p>This method assumes valid UTF8 input. This method  
 <strong>does not perform</strong> full UTF8 validation, it will check only the 
  first byte of each codepoint (for multi-byte sequences any bytes after 
  the head are skipped).
 @throw IllegalArgumentExceptionIf invalid codepoint header byte occurs or the 
     content is prematurely truncated.
 */
+ (jint)codePointCountWithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)utf8;

/*!
 @brief Cover JDK 1.5 API.Create a String from an array of codePoints.
 @param codePoints The code array
 @param offset The start of the text in the code point array
 @param count The number of code points
 @return a String representing the code points between offset and count
 @throw IllegalArgumentExceptionIf an invalid code point is encountered
 @throw IndexOutOfBoundsExceptionIf the offset or count are out of bounds.
 */
+ (NSString *)newStringWithIntArray:(IOSIntArray *)codePoints
                            withInt:(jint)offset
                            withInt:(jint)count OBJC_METHOD_FAMILY_NONE;

+ (NSString *)toHexStringWithNSString:(NSString *)s;

/*!
 @brief Encode characters from a char[] source, starting at
   offset for length chars.It is the responsibility of the
   caller to make sure that the destination array is large enough.
 */
+ (jint)UTF16toUTF8WithCharArray:(IOSCharArray *)source
                         withInt:(jint)offset
                         withInt:(jint)length
                   withByteArray:(IOSByteArray *)outArg;

/*!
 @brief Encode characters from this String, starting at offset
   for length characters.It is the responsibility of the
   caller to make sure that the destination array is large enough.
 */
+ (jint)UTF16toUTF8WithJavaLangCharSequence:(id<JavaLangCharSequence>)s
                                    withInt:(jint)offset
                                    withInt:(jint)length
                              withByteArray:(IOSByteArray *)outArg;

/*!
 @brief Interprets the given byte array as UTF-8 and converts to UTF-16.It is the
  responsibility of the caller to make sure that the destination array is large enough.
 <p>
  NOTE: Full characters are read, even if this reads past the length passed (and
  can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).
  Explicit checks for valid UTF-8 are not performed.
 */
+ (jint)UTF8toUTF16WithByteArray:(IOSByteArray *)utf8
                         withInt:(jint)offset
                         withInt:(jint)length
                   withCharArray:(IOSCharArray *)outArg;

/*!
 @brief Utility method for <code>UTF8toUTF16(byte[], int, int, char[])</code>
 - seealso: #UTF8toUTF16(byte[], int, int, char[])
 */
+ (jint)UTF8toUTF16WithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)bytesRef
                                     withCharArray:(IOSCharArray *)chars;

/*!
 @brief <p>This method assumes valid UTF8 input.
 This method  
 <strong>does not perform</strong> full UTF8 validation, it will check only the 
  first byte of each codepoint (for multi-byte sequences any bytes after 
  the head are skipped). It is the responsibility of the caller to make sure
  that the destination array is large enough.
 @throw IllegalArgumentExceptionIf invalid codepoint header byte occurs or the 
     content is prematurely truncated.
 */
+ (jint)UTF8toUTF32WithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)utf8
                                      withIntArray:(IOSIntArray *)ints;

+ (jboolean)validUTF16StringWithCharArray:(IOSCharArray *)s
                                  withInt:(jint)size;

+ (jboolean)validUTF16StringWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneUtilUnicodeUtil)

/*!
 @brief A binary term consisting of a number of 0xff bytes, likely to be bigger than other terms
   (e.g.collation keys) one would normally encounter, and definitely bigger than any UTF-8 terms.
 <p>
   WARNING: This is not a valid UTF8 Term
 */
inline OrgApacheLuceneUtilBytesRef *OrgApacheLuceneUtilUnicodeUtil_get_BIG_TERM(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgApacheLuceneUtilBytesRef *OrgApacheLuceneUtilUnicodeUtil_BIG_TERM;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneUtilUnicodeUtil, BIG_TERM, OrgApacheLuceneUtilBytesRef *)

inline jint OrgApacheLuceneUtilUnicodeUtil_get_UNI_SUR_HIGH_START(void);
#define OrgApacheLuceneUtilUnicodeUtil_UNI_SUR_HIGH_START 55296
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, UNI_SUR_HIGH_START, jint)

inline jint OrgApacheLuceneUtilUnicodeUtil_get_UNI_SUR_HIGH_END(void);
#define OrgApacheLuceneUtilUnicodeUtil_UNI_SUR_HIGH_END 56319
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, UNI_SUR_HIGH_END, jint)

inline jint OrgApacheLuceneUtilUnicodeUtil_get_UNI_SUR_LOW_START(void);
#define OrgApacheLuceneUtilUnicodeUtil_UNI_SUR_LOW_START 56320
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, UNI_SUR_LOW_START, jint)

inline jint OrgApacheLuceneUtilUnicodeUtil_get_UNI_SUR_LOW_END(void);
#define OrgApacheLuceneUtilUnicodeUtil_UNI_SUR_LOW_END 57343
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, UNI_SUR_LOW_END, jint)

inline jint OrgApacheLuceneUtilUnicodeUtil_get_UNI_REPLACEMENT_CHAR(void);
#define OrgApacheLuceneUtilUnicodeUtil_UNI_REPLACEMENT_CHAR 65533
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, UNI_REPLACEMENT_CHAR, jint)

/*!
 @brief Maximum number of UTF8 bytes per UTF16 character.
 */
inline jint OrgApacheLuceneUtilUnicodeUtil_get_MAX_UTF8_BYTES_PER_CHAR(void);
#define OrgApacheLuceneUtilUnicodeUtil_MAX_UTF8_BYTES_PER_CHAR 3
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneUtilUnicodeUtil, MAX_UTF8_BYTES_PER_CHAR, jint)

inline IOSIntArray *OrgApacheLuceneUtilUnicodeUtil_get_utf8CodeLength(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *OrgApacheLuceneUtilUnicodeUtil_utf8CodeLength;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneUtilUnicodeUtil, utf8CodeLength, IOSIntArray *)

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_UTF16toUTF8WithCharArray_withInt_withInt_withByteArray_(IOSCharArray *source, jint offset, jint length, IOSByteArray *outArg);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_UTF16toUTF8WithJavaLangCharSequence_withInt_withInt_withByteArray_(id<JavaLangCharSequence> s, jint offset, jint length, IOSByteArray *outArg);

FOUNDATION_EXPORT jboolean OrgApacheLuceneUtilUnicodeUtil_validUTF16StringWithJavaLangCharSequence_(id<JavaLangCharSequence> s);

FOUNDATION_EXPORT jboolean OrgApacheLuceneUtilUnicodeUtil_validUTF16StringWithCharArray_withInt_(IOSCharArray *s, jint size);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_codePointCountWithOrgApacheLuceneUtilBytesRef_(OrgApacheLuceneUtilBytesRef *utf8);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_UTF8toUTF32WithOrgApacheLuceneUtilBytesRef_withIntArray_(OrgApacheLuceneUtilBytesRef *utf8, IOSIntArray *ints);

FOUNDATION_EXPORT NSString *OrgApacheLuceneUtilUnicodeUtil_newStringWithIntArray_withInt_withInt_(IOSIntArray *codePoints, jint offset, jint count);

FOUNDATION_EXPORT NSString *OrgApacheLuceneUtilUnicodeUtil_toHexStringWithNSString_(NSString *s);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_UTF8toUTF16WithByteArray_withInt_withInt_withCharArray_(IOSByteArray *utf8, jint offset, jint length, IOSCharArray *outArg);

FOUNDATION_EXPORT jint OrgApacheLuceneUtilUnicodeUtil_UTF8toUTF16WithOrgApacheLuceneUtilBytesRef_withCharArray_(OrgApacheLuceneUtilBytesRef *bytesRef, IOSCharArray *chars);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneUtilUnicodeUtil)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneUtilUnicodeUtil")
