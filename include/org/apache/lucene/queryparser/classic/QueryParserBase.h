//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase")
#ifdef RESTRICT_OrgApacheLuceneQueryparserClassicQueryParserBase
#define INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase 0
#else
#define INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase 1
#endif
#undef RESTRICT_OrgApacheLuceneQueryparserClassicQueryParserBase

#if !defined (OrgApacheLuceneQueryparserClassicQueryParserBase_) && (INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase || defined(INCLUDE_OrgApacheLuceneQueryparserClassicQueryParserBase))
#define OrgApacheLuceneQueryparserClassicQueryParserBase_

#define RESTRICT_OrgApacheLuceneUtilQueryBuilder 1
#define INCLUDE_OrgApacheLuceneUtilQueryBuilder 1
#include "org/apache/lucene/util/QueryBuilder.h"

#define RESTRICT_OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration 1
#define INCLUDE_OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration 1
#include "org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.h"

@class JavaUtilLocale;
@class JavaUtilTimeZone;
@class OrgApacheLuceneAnalysisAnalyzer;
@class OrgApacheLuceneDocumentDateTools_Resolution;
@class OrgApacheLuceneIndexTerm;
@class OrgApacheLuceneQueryparserClassicQueryParser_Operator;
@class OrgApacheLuceneQueryparserClassicToken;
@class OrgApacheLuceneSearchBooleanClause;
@class OrgApacheLuceneSearchBooleanClause_Occur;
@class OrgApacheLuceneSearchMultiTermQuery_RewriteMethod;
@class OrgApacheLuceneSearchQuery;
@class OrgApacheLuceneUtilBytesRef;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol OrgApacheLuceneQueryparserClassicCharStream;

/*!
 @brief This class is overridden by QueryParser in QueryParser.jj
 and acts to separate the majority of the Java code from the .jj grammar file.
 */
@interface OrgApacheLuceneQueryparserClassicQueryParserBase : OrgApacheLuceneUtilQueryBuilder < OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration > {
 @public
  /*!
   @brief The actual operator that parser uses to combine query terms
   */
  OrgApacheLuceneQueryparserClassicQueryParser_Operator *operator__;
  jboolean lowercaseExpandedTerms_;
  OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *multiTermRewriteMethod_;
  jboolean allowLeadingWildcard_;
  NSString *field_;
  jint phraseSlop_;
  jfloat fuzzyMinSim_;
  jint fuzzyPrefixLength_;
  JavaUtilLocale *locale_;
  JavaUtilTimeZone *timeZone_;
  OrgApacheLuceneDocumentDateTools_Resolution *dateResolution_;
  id<JavaUtilMap> fieldToDateResolution_;
  jboolean analyzeRangeTerms_;
  jboolean autoGeneratePhraseQueries_;
  jint maxDeterminizedStates_;
}

+ (jint)CONJ_NONE;

+ (jint)CONJ_AND;

+ (jint)CONJ_OR;

+ (jint)MOD_NONE;

+ (jint)MOD_NOT;

+ (jint)MOD_REQ;

+ (OrgApacheLuceneQueryparserClassicQueryParser_Operator *)AND_OPERATOR;

+ (OrgApacheLuceneQueryparserClassicQueryParser_Operator *)OR_OPERATOR;

#pragma mark Public

/*!
 @brief Returns a String where those characters that QueryParser
 expects to be escaped are escaped by a preceding <code>\</code>.
 */
+ (NSString *)escapeWithNSString:(NSString *)s;

/*!
 - seealso: #setAllowLeadingWildcard(boolean)
 */
- (jboolean)getAllowLeadingWildcard;

/*!
 @return whether or not to analyze range terms when constructing <code>TermRangeQuery</code>s.
 */
- (jboolean)getAnalyzeRangeTerms;

/*!
 - seealso: #setAutoGeneratePhraseQueries(boolean)
 */
- (jboolean)getAutoGeneratePhraseQueries;

/*!
 @brief Returns the date resolution that is used by RangeQueries for the given field.
 Returns null, if no default or field specific date resolution has been set
 for the given field.
 */
- (OrgApacheLuceneDocumentDateTools_Resolution *)getDateResolutionWithNSString:(NSString *)fieldName;

/*!
 @brief Gets implicit operator setting, which will be either AND_OPERATOR
 or OR_OPERATOR.
 */
- (OrgApacheLuceneQueryparserClassicQueryParser_Operator *)getDefaultOperator;

/*!
 @return Returns the default field.
 */
- (NSString *)getField;

/*!
 @brief Get the minimal similarity for fuzzy queries.
 */
- (jfloat)getFuzzyMinSim;

/*!
 @brief Get the prefix length for fuzzy queries.
 @return Returns the fuzzyPrefixLength.
 */
- (jint)getFuzzyPrefixLength;

/*!
 @brief Returns current locale, allowing access by subclasses.
 */
- (JavaUtilLocale *)getLocale;

/*!
 - seealso: #setLowercaseExpandedTerms(boolean)
 */
- (jboolean)getLowercaseExpandedTerms;

/*!
 @return the maximum number of states that determinizing a regexp query
 can result in.  If the query results in any more states a
 TooComplexToDeterminizeException is thrown.
 */
- (jint)getMaxDeterminizedStates;

/*!
 - seealso: #setMultiTermRewriteMethod
 */
- (OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)getMultiTermRewriteMethod;

/*!
 @brief Gets the default slop for phrases.
 */
- (jint)getPhraseSlop;

- (JavaUtilTimeZone *)getTimeZone;

/*!
 @brief Initializes a query parser.
 Called by the QueryParser constructor
 @param f  the default field for query terms.
 @param a   used to find terms in the query text.
 */
- (void)init__WithNSString:(NSString *)f
withOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)a OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Parses a query string, returning a <code>org.apache.lucene.search.Query</code>.
 @param query  the query string to be parsed.
 @throws ParseException if the parsing fails
 */
- (OrgApacheLuceneSearchQuery *)parseWithNSString:(NSString *)query;

- (void)ReInitWithOrgApacheLuceneQueryparserClassicCharStream:(id<OrgApacheLuceneQueryparserClassicCharStream>)stream;

/*!
 @brief Set to <code>true</code> to allow leading wildcard characters.
 <p>
 When set, <code>*</code> or <code>?</code> are allowed as
 the first character of a PrefixQuery and WildcardQuery.
 Note that this can produce very slow
 queries on big indexes.
 <p>
 Default: false.
 */
- (void)setAllowLeadingWildcardWithBoolean:(jboolean)allowLeadingWildcard;

/*!
 @brief Set whether or not to analyze range terms when constructing <code>TermRangeQuery</code>s.
 For example, setting this to true can enable analyzing terms into 
 collation keys for locale-sensitive <code>TermRangeQuery</code>.
 @param analyzeRangeTerms whether or not terms should be analyzed for RangeQuerys
 */
- (void)setAnalyzeRangeTermsWithBoolean:(jboolean)analyzeRangeTerms;

/*!
 @brief Set to true if phrase queries will be automatically generated
 when the analyzer returns more than one term from whitespace
 delimited text.
 NOTE: this behavior may not be suitable for all languages.
 <p>
 Set to false if phrase queries should only be generated when
 surrounded by double quotes.
 */
- (void)setAutoGeneratePhraseQueriesWithBoolean:(jboolean)value;

/*!
 @brief Sets the default date resolution used by RangeQueries for fields for which no
 specific date resolutions has been set.
 Field specific resolutions can be set
 with <code>setDateResolution(String,org.apache.lucene.document.DateTools.Resolution)</code>.
 @param dateResolution the default date resolution to set
 */
- (void)setDateResolutionWithOrgApacheLuceneDocumentDateTools_Resolution:(OrgApacheLuceneDocumentDateTools_Resolution *)dateResolution;

/*!
 @brief Sets the date resolution used by RangeQueries for a specific field.
 @param fieldName field for which the date resolution is to be set
 @param dateResolution date resolution to set
 */
- (void)setDateResolutionWithNSString:(NSString *)fieldName
withOrgApacheLuceneDocumentDateTools_Resolution:(OrgApacheLuceneDocumentDateTools_Resolution *)dateResolution;

/*!
 @brief Sets the boolean operator of the QueryParser.
 In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
 are considered optional: for example <code>capital of Hungary</code> is equal to
 <code>capital OR of OR Hungary</code>.<br>
 In <code>AND_OPERATOR</code> mode terms are considered to be in conjunction: the
 above mentioned query is parsed as <code>capital AND of AND Hungary</code>
 */
- (void)setDefaultOperatorWithOrgApacheLuceneQueryparserClassicQueryParser_Operator:(OrgApacheLuceneQueryparserClassicQueryParser_Operator *)op;

/*!
 @brief Set the minimum similarity for fuzzy queries.
 Default is 2f.
 */
- (void)setFuzzyMinSimWithFloat:(jfloat)fuzzyMinSim;

/*!
 @brief Set the prefix length for fuzzy queries.
 Default is 0.
 @param fuzzyPrefixLength The fuzzyPrefixLength to set.
 */
- (void)setFuzzyPrefixLengthWithInt:(jint)fuzzyPrefixLength;

/*!
 @brief Set locale used by date range parsing, lowercasing, and other
 locale-sensitive operations.
 */
- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
 lower-cased or not.
 Default is <code>true</code>.
 */
- (void)setLowercaseExpandedTermsWithBoolean:(jboolean)lowercaseExpandedTerms;

/*!
 @param maxDeterminizedStates the maximum number of states that
 determinizing a regexp query can result in.  If the query results in any
 more states a TooComplexToDeterminizeException is thrown.
 */
- (void)setMaxDeterminizedStatesWithInt:(jint)maxDeterminizedStates;

/*!
 @brief By default QueryParser uses <code>org.apache.lucene.search.MultiTermQuery.CONSTANT_SCORE_REWRITE</code>
 when creating a <code>PrefixQuery</code>, <code>WildcardQuery</code> or <code>TermRangeQuery</code>.
 This implementation is generally preferable because it
 a) Runs faster b) Does not have the scarcity of terms unduly influence score
 c) avoids any <code>TooManyClauses</code> exception.
 However, if your application really needs to use the
 old-fashioned <code>BooleanQuery</code> expansion rewriting and the above
 points are not relevant then use this to change
 the rewrite method.
 */
- (void)setMultiTermRewriteMethodWithOrgApacheLuceneSearchMultiTermQuery_RewriteMethod:(OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)method;

/*!
 @brief Sets the default slop for phrases.
 If zero, then exact phrase matches
 are required.  Default value is zero.
 */
- (void)setPhraseSlopWithInt:(jint)phraseSlop;

- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

- (OrgApacheLuceneSearchQuery *)TopLevelQueryWithNSString:(NSString *)field;

#pragma mark Protected

- (instancetype)init;

- (void)addClauseWithJavaUtilList:(id<JavaUtilList>)clauses
                          withInt:(jint)conj
                          withInt:(jint)mods
   withOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q;

- (OrgApacheLuceneUtilBytesRef *)analyzeMultitermTermWithNSString:(NSString *)field
                                                     withNSString:(NSString *)part
                              withOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)analyzerIn;

/*!
 @brief Factory method for generating query, given a set of clauses.
 By default creates a boolean query composed of clauses passed in.
 Can be overridden by extending classes, to modify query being
 returned.
 @param clauses List that contains <code>org.apache.lucene.search.BooleanClause</code> instances
 to join.
 @return Resulting <code>org.apache.lucene.search.Query</code> object.
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getBooleanQueryWithJavaUtilList:(id<JavaUtilList>)clauses;

/*!
 @brief Factory method for generating query, given a set of clauses.
 By default creates a boolean query composed of clauses passed in.
 Can be overridden by extending classes, to modify query being
 returned.
 @param clauses List that contains <code>org.apache.lucene.search.BooleanClause</code> instances
 to join.
 @param disableCoord true if coord scoring should be disabled.
 @return Resulting <code>org.apache.lucene.search.Query</code> object.
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getBooleanQueryWithJavaUtilList:(id<JavaUtilList>)clauses
                                                    withBoolean:(jboolean)disableCoord;

/*!
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFieldQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)queryText
                                              withBoolean:(jboolean)quoted;

/*!
 @brief Base implementation delegates to <code>getFieldQuery(String,String,boolean)</code>.
 This method may be overridden, for example, to return
 a SpanNearQuery instead of a PhraseQuery.
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFieldQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)queryText
                                                  withInt:(jint)slop;

/*!
 @brief Factory method for generating a query (similar to
 <code>getWildcardQuery</code>).
 Called when parser parses
 an input term token that has the fuzzy suffix (~) appended.
 @param field Name of the field query will use.
 @param termStr Term token to use for building term for the query
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFuzzyQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)termStr
                                                withFloat:(jfloat)minSimilarity;

/*!
 @brief Factory method for generating a query (similar to
 <code>getWildcardQuery</code>).
 Called when parser parses an input term
 token that uses prefix notation; that is, contains a single '*' wildcard
 character as its last character. Since this is a special case
 of generic wildcard term, and such a query can be optimized easily,
 this usually results in a different query object.
 <p>
 Depending on settings, a prefix term may be lower-cased
 automatically. It will not go through the default Analyzer,
 however, since normal Analyzers are unlikely to work properly
 with wildcard templates.
 <p>
 Can be overridden by extending classes, to provide custom handling for
 wild card queries, which may be necessary due to missing analyzer calls.
 @param field Name of the field query will use.
 @param termStr Term token to use for building term for the query
 (<b>without</b> trailing '*' character!)
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getPrefixQueryWithNSString:(NSString *)field
                                              withNSString:(NSString *)termStr;

- (OrgApacheLuceneSearchQuery *)getRangeQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)part1
                                             withNSString:(NSString *)part2
                                              withBoolean:(jboolean)startInclusive
                                              withBoolean:(jboolean)endInclusive;

/*!
 @brief Factory method for generating a query.
 Called when parser
 parses an input term token that contains a regular expression
 query.
 <p>
 Depending on settings, pattern term may be lower-cased
 automatically. It will not go through the default Analyzer,
 however, since normal Analyzers are unlikely to work properly
 with regular expression templates.
 <p>
 Can be overridden by extending classes, to provide custom handling for
 regular expression queries, which may be necessary due to missing analyzer
 calls.
 @param field Name of the field query will use.
 @param termStr Term token that contains a regular expression
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getRegexpQueryWithNSString:(NSString *)field
                                              withNSString:(NSString *)termStr;

/*!
 @brief Factory method for generating a query.
 Called when parser
 parses an input term token that contains one or more wildcard
 characters (? and *), but is not a prefix term token (one
 that has just a single * character at the end)
 <p>
 Depending on settings, prefix term may be lower-cased
 automatically. It will not go through the default Analyzer,
 however, since normal Analyzers are unlikely to work properly
 with wildcard templates.
 <p>
 Can be overridden by extending classes, to provide custom handling for
 wildcard queries, which may be necessary due to missing analyzer calls.
 @param field Name of the field query will use.
 @param termStr Term token that contains one or more wild card
 characters (? or *), but is not simple prefix term
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getWildcardQueryWithNSString:(NSString *)field
                                                withNSString:(NSString *)termStr;

/*!
 @brief Builds a new BooleanClause instance
 @param q sub query
 @param occur how this clause should occur when matching documents
 @return new BooleanClause instance
 */
- (OrgApacheLuceneSearchBooleanClause *)newBooleanClauseWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q
                                          withOrgApacheLuceneSearchBooleanClause_Occur:(OrgApacheLuceneSearchBooleanClause_Occur *)occur OBJC_METHOD_FAMILY_NONE;

/*!
 @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)newFieldQueryWithOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)analyzer
                                                                    withNSString:(NSString *)field
                                                                    withNSString:(NSString *)queryText
                                                                     withBoolean:(jboolean)quoted OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new FuzzyQuery instance
 @param term Term
 @param minimumSimilarity minimum similarity
 @param prefixLength prefix length
 @return new FuzzyQuery Instance
 */
- (OrgApacheLuceneSearchQuery *)newFuzzyQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)term
                                                                withFloat:(jfloat)minimumSimilarity
                                                                  withInt:(jint)prefixLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new MatchAllDocsQuery instance
 @return new MatchAllDocsQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newMatchAllDocsQuery OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new PrefixQuery instance
 @param prefix Prefix term
 @return new PrefixQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newPrefixQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)prefix OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new <code>TermRangeQuery</code> instance
 @param field Field
 @param part1 min
 @param part2 max
 @param startInclusive true if the start of the range is inclusive
 @param endInclusive true if the end of the range is inclusive
 @return new <code>TermRangeQuery</code> instance
 */
- (OrgApacheLuceneSearchQuery *)newRangeQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)part1
                                             withNSString:(NSString *)part2
                                              withBoolean:(jboolean)startInclusive
                                              withBoolean:(jboolean)endInclusive OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new RegexpQuery instance
 @param regexp Regexp term
 @return new RegexpQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newRegexpQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)regexp OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new WildcardQuery instance
 @param t wildcard term
 @return new WildcardQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newWildcardQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)t OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

/*!
 @brief Returns a String where the escape char has been
 removed, or kept only once if there was a double escape.
 Supports escaped unicode characters, e. g. translates
 <code>\\u0041</code> to <code>A</code>.
 */
- (NSString *)discardEscapeCharWithNSString:(NSString *)input;

- (OrgApacheLuceneSearchQuery *)handleBareFuzzyWithNSString:(NSString *)qfield
                 withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop
                                               withNSString:(NSString *)termImage;

- (OrgApacheLuceneSearchQuery *)handleBareTokenQueryWithNSString:(NSString *)qfield
                      withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)term
                      withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop
                                                     withBoolean:(jboolean)prefix
                                                     withBoolean:(jboolean)wildcard
                                                     withBoolean:(jboolean)fuzzy
                                                     withBoolean:(jboolean)regexp;

- (OrgApacheLuceneSearchQuery *)handleBoostWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q
                               withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)boost;

- (OrgApacheLuceneSearchQuery *)handleQuotedTermWithNSString:(NSString *)qfield
                  withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)term
                  withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop;

/*!
 @brief Returns the numeric value of the hexadecimal character
 */
+ (jint)hexToIntWithChar:(jchar)c;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneQueryparserClassicQueryParserBase)

J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, operator__, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, multiTermRewriteMethod_, OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, field_, NSString *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, locale_, JavaUtilLocale *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, timeZone_, JavaUtilTimeZone *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, dateResolution_, OrgApacheLuceneDocumentDateTools_Resolution *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, fieldToDateResolution_, id<JavaUtilMap>)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_NONE();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_NONE, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_AND();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_AND 1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_AND, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_OR();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_OR 2
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_OR, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_NONE();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_NONE, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_NOT();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_NOT 10
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_NOT, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_REQ();
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_REQ 11
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_REQ, jint)

/*!
 @brief Alternative form of QueryParser.Operator.AND
 */
inline OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_get_AND_OPERATOR();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_AND_OPERATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneQueryparserClassicQueryParserBase, AND_OPERATOR, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)

/*!
 @brief Alternative form of QueryParser.Operator.OR
 */
inline OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_get_OR_OPERATOR();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_OR_OPERATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneQueryparserClassicQueryParserBase, OR_OPERATOR, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)

FOUNDATION_EXPORT void OrgApacheLuceneQueryparserClassicQueryParserBase_init(OrgApacheLuceneQueryparserClassicQueryParserBase *self);

FOUNDATION_EXPORT jint OrgApacheLuceneQueryparserClassicQueryParserBase_hexToIntWithChar_(jchar c);

FOUNDATION_EXPORT NSString *OrgApacheLuceneQueryparserClassicQueryParserBase_escapeWithNSString_(NSString *s);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneQueryparserClassicQueryParserBase)

#endif

#if !defined (OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_) && (INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase || defined(INCLUDE_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother))
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_

/*!
 @brief Do not catch this exception in your code, it means you are using methods that you should no longer use.
 */
@interface OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother : NSException

#pragma mark Public

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother)

FOUNDATION_EXPORT void OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *self);

FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *new_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *create_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init();

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase")
