//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase")
#ifdef RESTRICT_OrgApacheLuceneQueryparserClassicQueryParserBase
#define INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase 0
#else
#define INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase 1
#endif
#undef RESTRICT_OrgApacheLuceneQueryparserClassicQueryParserBase

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheLuceneQueryparserClassicQueryParserBase_) && (INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase || defined(INCLUDE_OrgApacheLuceneQueryparserClassicQueryParserBase))
#define OrgApacheLuceneQueryparserClassicQueryParserBase_

#define RESTRICT_OrgApacheLuceneUtilQueryBuilder 1
#define INCLUDE_OrgApacheLuceneUtilQueryBuilder 1
#include "org/apache/lucene/util/QueryBuilder.h"

#define RESTRICT_OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration 1
#define INCLUDE_OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration 1
#include "org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.h"

@class JavaUtilLocale;
@class JavaUtilTimeZone;
@class OrgApacheLuceneAnalysisAnalyzer;
@class OrgApacheLuceneDocumentDateTools_Resolution;
@class OrgApacheLuceneIndexTerm;
@class OrgApacheLuceneQueryparserClassicQueryParser_Operator;
@class OrgApacheLuceneQueryparserClassicToken;
@class OrgApacheLuceneSearchBooleanClause;
@class OrgApacheLuceneSearchBooleanClause_Occur;
@class OrgApacheLuceneSearchMultiTermQuery_RewriteMethod;
@class OrgApacheLuceneSearchQuery;
@class OrgApacheLuceneUtilBytesRef;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol OrgApacheLuceneQueryparserClassicCharStream;

/*!
 @brief This class is overridden by QueryParser in QueryParser.jj
  and acts to separate the majority of the Java code from the .jj grammar file.
 */
@interface OrgApacheLuceneQueryparserClassicQueryParserBase : OrgApacheLuceneUtilQueryBuilder < OrgApacheLuceneQueryparserFlexibleStandardCommonQueryParserConfiguration > {
 @public
  /*!
   @brief The actual operator that parser uses to combine query terms
   */
  OrgApacheLuceneQueryparserClassicQueryParser_Operator *operator__;
  jboolean lowercaseExpandedTerms_;
  OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *multiTermRewriteMethod_;
  jboolean allowLeadingWildcard_;
  NSString *field_;
  jint phraseSlop_;
  jfloat fuzzyMinSim_;
  jint fuzzyPrefixLength_;
  JavaUtilLocale *locale_;
  JavaUtilTimeZone *timeZone_;
  OrgApacheLuceneDocumentDateTools_Resolution *dateResolution_;
  id<JavaUtilMap> fieldToDateResolution_;
  jboolean analyzeRangeTerms_;
  jboolean autoGeneratePhraseQueries_;
  jint maxDeterminizedStates_;
}
@property (readonly, class) jint CONJ_NONE NS_SWIFT_NAME(CONJ_NONE);
@property (readonly, class) jint CONJ_AND NS_SWIFT_NAME(CONJ_AND);
@property (readonly, class) jint CONJ_OR NS_SWIFT_NAME(CONJ_OR);
@property (readonly, class) jint MOD_NONE NS_SWIFT_NAME(MOD_NONE);
@property (readonly, class) jint MOD_NOT NS_SWIFT_NAME(MOD_NOT);
@property (readonly, class) jint MOD_REQ NS_SWIFT_NAME(MOD_REQ);
@property (readonly, class, strong) OrgApacheLuceneQueryparserClassicQueryParser_Operator *AND_OPERATOR NS_SWIFT_NAME(AND_OPERATOR);
@property (readonly, class, strong) OrgApacheLuceneQueryparserClassicQueryParser_Operator *OR_OPERATOR NS_SWIFT_NAME(OR_OPERATOR);

#pragma mark Public

/*!
 @brief Returns a String where those characters that QueryParser
  expects to be escaped are escaped by a preceding <code>\</code>.
 */
+ (NSString *)escapeWithNSString:(NSString *)s;

/*!
 - seealso: #setAllowLeadingWildcard(boolean)
 */
- (jboolean)getAllowLeadingWildcard;

/*!
 @return whether or not to analyze range terms when constructing <code>TermRangeQuery</code>s.
 */
- (jboolean)getAnalyzeRangeTerms;

/*!
 - seealso: #setAutoGeneratePhraseQueries(boolean)
 */
- (jboolean)getAutoGeneratePhraseQueries;

/*!
 @brief Returns the date resolution that is used by RangeQueries for the given field.
 Returns null, if no default or field specific date resolution has been set
  for the given field.
 */
- (OrgApacheLuceneDocumentDateTools_Resolution *)getDateResolutionWithNSString:(NSString *)fieldName;

/*!
 @brief Gets implicit operator setting, which will be either AND_OPERATOR
  or OR_OPERATOR.
 */
- (OrgApacheLuceneQueryparserClassicQueryParser_Operator *)getDefaultOperator;

/*!
 @return Returns the default field.
 */
- (NSString *)getField;

/*!
 @brief Get the minimal similarity for fuzzy queries.
 */
- (jfloat)getFuzzyMinSim;

/*!
 @brief Get the prefix length for fuzzy queries.
 @return Returns the fuzzyPrefixLength.
 */
- (jint)getFuzzyPrefixLength;

/*!
 @brief Returns current locale, allowing access by subclasses.
 */
- (JavaUtilLocale *)getLocale;

/*!
 - seealso: #setLowercaseExpandedTerms(boolean)
 */
- (jboolean)getLowercaseExpandedTerms;

/*!
 @return the maximum number of states that determinizing a regexp query
    can result in.  If the query results in any more states a
    TooComplexToDeterminizeException is thrown.
 */
- (jint)getMaxDeterminizedStates;

/*!
 - seealso: #setMultiTermRewriteMethod
 */
- (OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)getMultiTermRewriteMethod;

/*!
 @brief Gets the default slop for phrases.
 */
- (jint)getPhraseSlop;

- (JavaUtilTimeZone *)getTimeZone;

/*!
 @brief Initializes a query parser.Called by the QueryParser constructor
 @param f the default field for query terms.
 @param a used to find terms in the query text.
 */
- (void)init__WithNSString:(NSString *)f
withOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)a OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Parses a query string, returning a <code>org.apache.lucene.search.Query</code>.
 @param query the query string to be parsed.
 @throw ParseExceptionif the parsing fails
 */
- (OrgApacheLuceneSearchQuery *)parseWithNSString:(NSString *)query;

- (void)ReInitWithOrgApacheLuceneQueryparserClassicCharStream:(id<OrgApacheLuceneQueryparserClassicCharStream>)stream;

/*!
 @brief Set to <code>true</code> to allow leading wildcard characters.
 <p>
  When set, <code>
 *</code> or <code>?</code> are allowed as the first character of a PrefixQuery and WildcardQuery.
  Note that this can produce very slow
  queries on big indexes. 
 <p>
  Default: false.
 */
- (void)setAllowLeadingWildcardWithBoolean:(jboolean)allowLeadingWildcard;

/*!
 @brief Set whether or not to analyze range terms when constructing <code>TermRangeQuery</code>s.
 For example, setting this to true can enable analyzing terms into 
  collation keys for locale-sensitive <code>TermRangeQuery</code>.
 @param analyzeRangeTerms whether or not terms should be analyzed for RangeQuerys
 */
- (void)setAnalyzeRangeTermsWithBoolean:(jboolean)analyzeRangeTerms;

/*!
 @brief Set to true if phrase queries will be automatically generated
  when the analyzer returns more than one term from whitespace
  delimited text.
 NOTE: this behavior may not be suitable for all languages. 
 <p>
  Set to false if phrase queries should only be generated when
  surrounded by double quotes.
 */
- (void)setAutoGeneratePhraseQueriesWithBoolean:(jboolean)value;

/*!
 @brief Sets the default date resolution used by RangeQueries for fields for which no
  specific date resolutions has been set.Field specific resolutions can be set
  with <code>setDateResolution(String, org.apache.lucene.document.DateTools.Resolution)</code>.
 @param dateResolution the default date resolution to set
 */
- (void)setDateResolutionWithOrgApacheLuceneDocumentDateTools_Resolution:(OrgApacheLuceneDocumentDateTools_Resolution *)dateResolution;

/*!
 @brief Sets the date resolution used by RangeQueries for a specific field.
 @param fieldName field for which the date resolution is to be set
 @param dateResolution date resolution to set
 */
- (void)setDateResolutionWithNSString:(NSString *)fieldName
withOrgApacheLuceneDocumentDateTools_Resolution:(OrgApacheLuceneDocumentDateTools_Resolution *)dateResolution;

/*!
 @brief Sets the boolean operator of the QueryParser.
 In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
  are considered optional: for example <code>capital of Hungary</code> is equal to 
 <code>capital OR of OR Hungary</code>.<br>
  In <code>AND_OPERATOR</code> mode terms are considered to be in conjunction: the
  above mentioned query is parsed as <code>capital AND of AND Hungary</code>
 */
- (void)setDefaultOperatorWithOrgApacheLuceneQueryparserClassicQueryParser_Operator:(OrgApacheLuceneQueryparserClassicQueryParser_Operator *)op;

/*!
 @brief Set the minimum similarity for fuzzy queries.
 Default is 2f.
 */
- (void)setFuzzyMinSimWithFloat:(jfloat)fuzzyMinSim;

/*!
 @brief Set the prefix length for fuzzy queries.Default is 0.
 @param fuzzyPrefixLength The fuzzyPrefixLength to set.
 */
- (void)setFuzzyPrefixLengthWithInt:(jint)fuzzyPrefixLength;

/*!
 @brief Set locale used by date range parsing, lowercasing, and other
  locale-sensitive operations.
 */
- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
  lower-cased or not.Default is <code>true</code>.
 */
- (void)setLowercaseExpandedTermsWithBoolean:(jboolean)lowercaseExpandedTerms;

/*!
 @param maxDeterminizedStates the maximum number of states that    determinizing a regexp query can result in.  If the query results in any
     more states a TooComplexToDeterminizeException is thrown.
 */
- (void)setMaxDeterminizedStatesWithInt:(jint)maxDeterminizedStates;

/*!
 @brief By default QueryParser uses <code>org.apache.lucene.search.MultiTermQuery.CONSTANT_SCORE_REWRITE</code>
  when creating a <code>PrefixQuery</code>, <code>WildcardQuery</code> or <code>TermRangeQuery</code>.This implementation is generally preferable because it
  a) Runs faster b) Does not have the scarcity of terms unduly influence score
  c) avoids any <code>TooManyClauses</code> exception.
 However, if your application really needs to use the
  old-fashioned <code>BooleanQuery</code> expansion rewriting and the above
  points are not relevant then use this to change
  the rewrite method.
 */
- (void)setMultiTermRewriteMethodWithOrgApacheLuceneSearchMultiTermQuery_RewriteMethod:(OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)method;

/*!
 @brief Sets the default slop for phrases.If zero, then exact phrase matches
  are required.
 Default value is zero.
 */
- (void)setPhraseSlopWithInt:(jint)phraseSlop;

- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

- (OrgApacheLuceneSearchQuery *)TopLevelQueryWithNSString:(NSString *)field;

#pragma mark Protected

- (instancetype __nonnull)init;

- (void)addClauseWithJavaUtilList:(id<JavaUtilList>)clauses
                          withInt:(jint)conj
                          withInt:(jint)mods
   withOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q;

- (OrgApacheLuceneUtilBytesRef *)analyzeMultitermTermWithNSString:(NSString *)field
                                                     withNSString:(NSString *)part
                              withOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)analyzerIn;

/*!
 @brief Factory method for generating query, given a set of clauses.
 By default creates a boolean query composed of clauses passed in.
  Can be overridden by extending classes, to modify query being
  returned.
 @param clauses List that contains <code>org.apache.lucene.search.BooleanClause</code>  instances
      to join.
 @return Resulting <code>org.apache.lucene.search.Query</code> object.
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getBooleanQueryWithJavaUtilList:(id<JavaUtilList>)clauses;

/*!
 @brief Factory method for generating query, given a set of clauses.
 By default creates a boolean query composed of clauses passed in.
  Can be overridden by extending classes, to modify query being
  returned.
 @param clauses List that contains <code>org.apache.lucene.search.BooleanClause</code>  instances
      to join.
 @param disableCoord true if coord scoring should be disabled.
 @return Resulting <code>org.apache.lucene.search.Query</code> object.
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getBooleanQueryWithJavaUtilList:(id<JavaUtilList>)clauses
                                                    withBoolean:(jboolean)disableCoord;

/*!
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFieldQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)queryText
                                              withBoolean:(jboolean)quoted;

/*!
 @brief Base implementation delegates to <code>getFieldQuery(String,String,boolean)</code>.
 This method may be overridden, for example, to return
  a SpanNearQuery instead of a PhraseQuery.
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFieldQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)queryText
                                                  withInt:(jint)slop;

/*!
 @brief Factory method for generating a query (similar to 
 <code>getWildcardQuery</code>).Called when parser parses
  an input term token that has the fuzzy suffix (~) appended.
 @param field Name of the field query will use.
 @param termStr Term token to use for building term for the query
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getFuzzyQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)termStr
                                                withFloat:(jfloat)minSimilarity;

/*!
 @brief Factory method for generating a query (similar to 
 <code>getWildcardQuery</code>).Called when parser parses an input term
  token that uses prefix notation; that is, contains a single '*' wildcard
  character as its last character.
 Since this is a special case
  of generic wildcard term, and such a query can be optimized easily,
  this usually results in a different query object.
 <p>
  Depending on settings, a prefix term may be lower-cased
  automatically. It will not go through the default Analyzer,
  however, since normal Analyzers are unlikely to work properly
  with wildcard templates.
 <p>
  Can be overridden by extending classes, to provide custom handling for
  wild card queries, which may be necessary due to missing analyzer calls.
 @param field Name of the field query will use.
 @param termStr Term token to use for building term for the query     (
  <b> without </b>  trailing '*' character!)
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getPrefixQueryWithNSString:(NSString *)field
                                              withNSString:(NSString *)termStr;

- (OrgApacheLuceneSearchQuery *)getRangeQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)part1
                                             withNSString:(NSString *)part2
                                              withBoolean:(jboolean)startInclusive
                                              withBoolean:(jboolean)endInclusive;

/*!
 @brief Factory method for generating a query.Called when parser
  parses an input term token that contains a regular expression
  query.
 <p>
  Depending on settings, pattern term may be lower-cased
  automatically. It will not go through the default Analyzer,
  however, since normal Analyzers are unlikely to work properly
  with regular expression templates.
 <p>
  Can be overridden by extending classes, to provide custom handling for
  regular expression queries, which may be necessary due to missing analyzer
  calls.
 @param field Name of the field query will use.
 @param termStr Term token that contains a regular expression
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getRegexpQueryWithNSString:(NSString *)field
                                              withNSString:(NSString *)termStr;

/*!
 @brief Factory method for generating a query.Called when parser
  parses an input term token that contains one or more wildcard
  characters (?
 and *), but is not a prefix term token (one
  that has just a single * character at the end)
 <p>
  Depending on settings, prefix term may be lower-cased
  automatically. It will not go through the default Analyzer,
  however, since normal Analyzers are unlikely to work properly
  with wildcard templates.
 <p>
  Can be overridden by extending classes, to provide custom handling for
  wildcard queries, which may be necessary due to missing analyzer calls.
 @param field Name of the field query will use.
 @param termStr Term token that contains one or more wild card    characters (? or *), but is not simple prefix term
 @return Resulting <code>org.apache.lucene.search.Query</code> built for the term
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)getWildcardQueryWithNSString:(NSString *)field
                                                withNSString:(NSString *)termStr;

/*!
 @brief Builds a new BooleanClause instance
 @param q sub query
 @param occur how this clause should occur when matching documents
 @return new BooleanClause instance
 */
- (OrgApacheLuceneSearchBooleanClause *)newBooleanClauseWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q
                                          withOrgApacheLuceneSearchBooleanClause_Occur:(OrgApacheLuceneSearchBooleanClause_Occur *)occur OBJC_METHOD_FAMILY_NONE;

/*!
 @throw org.apache.lucene.queryparser.classic.ParseExceptionthrow in overridden method to disallow
 */
- (OrgApacheLuceneSearchQuery *)newFieldQueryWithOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)analyzer
                                                                    withNSString:(NSString *)field
                                                                    withNSString:(NSString *)queryText
                                                                     withBoolean:(jboolean)quoted OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new FuzzyQuery instance
 @param term Term
 @param minimumSimilarity minimum similarity
 @param prefixLength prefix length
 @return new FuzzyQuery Instance
 */
- (OrgApacheLuceneSearchQuery *)newFuzzyQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)term
                                                                withFloat:(jfloat)minimumSimilarity
                                                                  withInt:(jint)prefixLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new MatchAllDocsQuery instance
 @return new MatchAllDocsQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newMatchAllDocsQuery OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new PrefixQuery instance
 @param prefix Prefix term
 @return new PrefixQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newPrefixQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)prefix OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new <code>TermRangeQuery</code> instance
 @param field Field
 @param part1 min
 @param part2 max
 @param startInclusive true if the start of the range is inclusive
 @param endInclusive true if the end of the range is inclusive
 @return new <code>TermRangeQuery</code> instance
 */
- (OrgApacheLuceneSearchQuery *)newRangeQueryWithNSString:(NSString *)field
                                             withNSString:(NSString *)part1
                                             withNSString:(NSString *)part2
                                              withBoolean:(jboolean)startInclusive
                                              withBoolean:(jboolean)endInclusive OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new RegexpQuery instance
 @param regexp Regexp term
 @return new RegexpQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newRegexpQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)regexp OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Builds a new WildcardQuery instance
 @param t wildcard term
 @return new WildcardQuery instance
 */
- (OrgApacheLuceneSearchQuery *)newWildcardQueryWithOrgApacheLuceneIndexTerm:(OrgApacheLuceneIndexTerm *)t OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

/*!
 @brief Returns a String where the escape char has been
  removed, or kept only once if there was a double escape.
 Supports escaped unicode characters, e. g. translates 
 <code>\\u0041</code> to <code>A</code>.
 */
- (NSString *)discardEscapeCharWithNSString:(NSString *)input;

- (OrgApacheLuceneSearchQuery *)handleBareFuzzyWithNSString:(NSString *)qfield
                 withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop
                                               withNSString:(NSString *)termImage;

- (OrgApacheLuceneSearchQuery *)handleBareTokenQueryWithNSString:(NSString *)qfield
                      withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)term
                      withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop
                                                     withBoolean:(jboolean)prefix
                                                     withBoolean:(jboolean)wildcard
                                                     withBoolean:(jboolean)fuzzy
                                                     withBoolean:(jboolean)regexp;

- (OrgApacheLuceneSearchQuery *)handleBoostWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)q
                               withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)boost;

- (OrgApacheLuceneSearchQuery *)handleQuotedTermWithNSString:(NSString *)qfield
                  withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)term
                  withOrgApacheLuceneQueryparserClassicToken:(OrgApacheLuceneQueryparserClassicToken *)fuzzySlop;

/*!
 @brief Returns the numeric value of the hexadecimal character
 */
+ (jint)hexToIntWithChar:(jchar)c;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithOrgApacheLuceneAnalysisAnalyzer:(OrgApacheLuceneAnalysisAnalyzer *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneQueryparserClassicQueryParserBase)

J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, operator__, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, multiTermRewriteMethod_, OrgApacheLuceneSearchMultiTermQuery_RewriteMethod *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, field_, NSString *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, locale_, JavaUtilLocale *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, timeZone_, JavaUtilTimeZone *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, dateResolution_, OrgApacheLuceneDocumentDateTools_Resolution *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneQueryparserClassicQueryParserBase, fieldToDateResolution_, id<JavaUtilMap>)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_NONE(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_NONE, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_AND(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_AND 1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_AND, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_CONJ_OR(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_CONJ_OR 2
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, CONJ_OR, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_NONE(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_NONE, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_NOT(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_NOT 10
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_NOT, jint)

inline jint OrgApacheLuceneQueryparserClassicQueryParserBase_get_MOD_REQ(void);
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MOD_REQ 11
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneQueryparserClassicQueryParserBase, MOD_REQ, jint)

/*!
 @brief Alternative form of QueryParser.Operator.AND
 */
inline OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_get_AND_OPERATOR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_AND_OPERATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneQueryparserClassicQueryParserBase, AND_OPERATOR, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)

/*!
 @brief Alternative form of QueryParser.Operator.OR
 */
inline OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_get_OR_OPERATOR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParser_Operator *OrgApacheLuceneQueryparserClassicQueryParserBase_OR_OPERATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneQueryparserClassicQueryParserBase, OR_OPERATOR, OrgApacheLuceneQueryparserClassicQueryParser_Operator *)

FOUNDATION_EXPORT void OrgApacheLuceneQueryparserClassicQueryParserBase_init(OrgApacheLuceneQueryparserClassicQueryParserBase *self);

FOUNDATION_EXPORT jint OrgApacheLuceneQueryparserClassicQueryParserBase_hexToIntWithChar_(jchar c);

FOUNDATION_EXPORT NSString *OrgApacheLuceneQueryparserClassicQueryParserBase_escapeWithNSString_(NSString *s);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneQueryparserClassicQueryParserBase)

#endif

#if !defined (OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_) && (INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase || defined(INCLUDE_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother))
#define OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_

#define RESTRICT_JavaLangThrowable 1
#define INCLUDE_JavaLangThrowable 1
#include "java/lang/Throwable.h"

/*!
 @brief Do not catch this exception in your code, it means you are using methods that you should no longer use.
 */
@interface OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother : JavaLangThrowable

#pragma mark Public

- (instancetype __nonnull)init;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaLangThrowable:(JavaLangThrowable *)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithNSString:(NSString *)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithNSString:(NSString *)arg0
                     withJavaLangThrowable:(JavaLangThrowable *)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithNSString:(NSString *)arg0
                     withJavaLangThrowable:(JavaLangThrowable *)arg1
                               withBoolean:(jboolean)arg2
                               withBoolean:(jboolean)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother)

FOUNDATION_EXPORT void OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *self);

FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *new_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother *create_OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother_init(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneQueryparserClassicQueryParserBase_MethodRemovedUseAnother)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneQueryparserClassicQueryParserBase")
