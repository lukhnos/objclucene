//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/similarities/package-info.java
//

/*!
 @brief This package contains the various ranking models that can be used in Lucene.The
  abstract class <code>org.apache.lucene.search.similarities.Similarity</code> serves
  as the base for ranking functions.
 For searching, users can employ the models
  already implemented or create their own by extending one of the classes in this
  package.  
 <h2>Table Of Contents</h2>
      <ol>
          <li><a href="#sims">Summary of the Ranking Methods</a></li>
          <li><a href="#changingSimilarity">Changing the Similarity</a></li>
      </ol>
    
 <a name="sims"></a>
  <h2>Summary of the Ranking Methods</h2>
   
 <p><code>org.apache.lucene.search.similarities.DefaultSimilarity</code> is the original Lucene
  scoring function. It is based on a highly optimized  
 <a href="http://en.wikipedia.org/wiki/Vector_Space_Model">Vector Space Model</a>. For more
  information, see <code>org.apache.lucene.search.similarities.TFIDFSimilarity</code>.
   
 <p><code>org.apache.lucene.search.similarities.BM25Similarity</code> is an optimized
  implementation of the successful Okapi BM25 model.  
 <p><code>org.apache.lucene.search.similarities.SimilarityBase</code> provides a basic
  implementation of the Similarity contract and exposes a highly simplified
  interface, which makes it an ideal starting point for new ranking functions.
  Lucene ships the following methods built on 
 <code>org.apache.lucene.search.similarities.SimilarityBase</code>:
   
 <a name="framework"></a>
  <ul>
    <li>Amati and Rijsbergen's DFR framework;</li>
    <li>Clinchant and Gaussier's Information-based models
      for IR;</li>
    <li>The implementation of two language models from
    Zhai and Lafferty's paper.</li>
  </ul>
  
  Since <code>org.apache.lucene.search.similarities.SimilarityBase</code> is not
  optimized to the same extent as 
 <code>org.apache.lucene.search.similarities.DefaultSimilarity</code> and 
 <code>org.apache.lucene.search.similarities.BM25Similarity</code>, a difference in
  performance is to be expected when using the methods listed above. However,
  optimizations can always be implemented in subclasses; see 
 <a href="#changingSimilarity">below</a>.
   
 <a name="changingSimilarity"></a>
  <h2>Changing Similarity</h2>
   
 <p>Chances are the available Similarities are sufficient for all
      your searching needs.
      However, in some applications it may be necessary to customize your <a href="Similarity.html">
 Similarity</a> implementation. For instance, some
      applications do not need to
      distinguish between shorter and longer documents (see <a href="http://www.gossamer-threads.com/lists/lucene/java-user/38967#38967">
 a "fair" similarity</a>).
   
 <p>To change <code>org.apache.lucene.search.similarities.Similarity</code>, one must do so for both indexing and
      searching, and the changes must happen before
      either of these actions take place. Although in theory there is nothing stopping you from changing mid-stream, it
      just isn't well-defined what is going to happen.  
 <p>To make this change, implement your own <code>org.apache.lucene.search.similarities.Similarity</code> (likely
      you'll want to simply subclass an existing method, be it     
 <code>org.apache.lucene.search.similarities.DefaultSimilarity</code> or a descendant of
      <code>org.apache.lucene.search.similarities.SimilarityBase</code>), and
      then register the new class by calling     
 <code>org.apache.lucene.index.IndexWriterConfig.setSimilarity(Similarity)</code>
      before indexing and     
 <code>org.apache.lucene.search.IndexSearcher.setSimilarity(Similarity)</code>
      before searching.  
 <h3>Extending org.apache.lucene.search.similarities.SimilarityBase</h3>
  <p>
  The easiest way to quickly implement a new ranking method is to extend 
 <code>org.apache.lucene.search.similarities.SimilarityBase</code>, which provides
  basic implementations for the low level . Subclasses are only required to
  implement the <code>org.apache.lucene.search.similarities.SimilarityBase.score(BasicStats, float, float)</code>
  and <code>org.apache.lucene.search.similarities.SimilarityBase.toString()</code>
  methods.  
 <p>Another option is to extend one of the <a href="#framework">frameworks</a>
  based on <code>org.apache.lucene.search.similarities.SimilarityBase</code>. These
  Similarities are implemented modularly, e.g. 
 <code>org.apache.lucene.search.similarities.DFRSimilarity</code> delegates
  computation of the three parts of its formula to the classes 
 <code>org.apache.lucene.search.similarities.BasicModel</code>,
  <code>org.apache.lucene.search.similarities.AfterEffect</code> and 
 <code>org.apache.lucene.search.similarities.Normalization</code>. Instead of
  subclassing the Similarity, one can simply introduce a new basic model and tell 
 <code>org.apache.lucene.search.similarities.DFRSimilarity</code> to use it.  
 <h3>Changing org.apache.lucene.search.similarities.DefaultSimilarity</h3>
  <p>
      If you are interested in use cases for changing your similarity, see the Lucene users's mailing list at <a href="http://www.gossamer-threads.com/lists/lucene/java-user/39125">
 Overriding Similarity</a>.
      In summary, here are a few use cases:     
 <ol>
          <li><p>The <code>SweetSpotSimilarity</code> in
              <code>org.apache.lucene.misc</code> gives small
              increases as the frequency increases a small amount
              and then greater increases when you hit the "sweet spot", i.e. where
              you think the frequency of terms is more significant.</li>
          <li><p>Overriding tf &mdash; In some applications, it doesn't matter what the score of a document is as long as a
              matching term occurs. In these
              cases people have overridden Similarity to return 1 from the tf() method.</li>
          <li><p>Changing Length Normalization &mdash; By overriding
              <code>org.apache.lucene.search.similarities.Similarity.computeNorm(org.apache.lucene.index.FieldInvertState state)</code>,
              it is possible to discount how the length of a field contributes
              to a score. In <code>org.apache.lucene.search.similarities.DefaultSimilarity</code>,
              lengthNorm = 1 / (numTerms in field)^0.5, but if one changes this to be
              1 / (numTerms in field), all fields will be treated             
 <a href="http://www.gossamer-threads.com/lists/lucene/java-user/38967#38967">"fairly"</a>.</li>
      </ol>
      In general, Chris Hostetter sums it up best in saying (from <a href="http://www.gossamer-threads.com/lists/lucene/java-user/39125#39125">
 the Lucene users's mailing list</a>):
      <blockquote>[One would override the Similarity in] ... any situation where you know more about your data then just
          that
          it's "text" is a situation where it *might* make sense to to override your
          Similarity method.</blockquote>
 */
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchSimilaritiesPackage_info")
#ifdef RESTRICT_OrgApacheLuceneSearchSimilaritiesPackage_info
#define INCLUDE_ALL_OrgApacheLuceneSearchSimilaritiesPackage_info 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchSimilaritiesPackage_info 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchSimilaritiesPackage_info

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchSimilaritiesPackage_info")
