//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./sandbox/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchDocValuesTermsQuery")
#ifdef RESTRICT_OrgApacheLuceneSearchDocValuesTermsQuery
#define INCLUDE_ALL_OrgApacheLuceneSearchDocValuesTermsQuery 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchDocValuesTermsQuery 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchDocValuesTermsQuery

#if !defined (OrgApacheLuceneSearchDocValuesTermsQuery_) && (INCLUDE_ALL_OrgApacheLuceneSearchDocValuesTermsQuery || defined(INCLUDE_OrgApacheLuceneSearchDocValuesTermsQuery))
#define OrgApacheLuceneSearchDocValuesTermsQuery_

#define RESTRICT_OrgApacheLuceneSearchQuery 1
#define INCLUDE_OrgApacheLuceneSearchQuery 1
#include "org/apache/lucene/search/Query.h"

@class IOSObjectArray;
@class OrgApacheLuceneSearchIndexSearcher;
@class OrgApacheLuceneSearchWeight;
@protocol JavaUtilCollection;

/*!
 @brief A <code>Query</code> that only accepts documents whose
 term value in the specified field is contained in the
 provided set of allowed terms.
 <p>
 This is the same functionality as TermsQuery (from
 queries/), but because of drastically different
 implementations, they also have different performance
 characteristics, as described below.
 <p>
 <b>NOTE</b>: be very careful using this query: it is
 typically much slower than using <code>TermsQuery</code>,
 but in certain specialized cases may be faster.
 <p>
 With each search, this query translates the specified
 set of Terms into a private <code>LongBitSet</code> keyed by
 term number per unique <code>IndexReader</code> (normally one
 reader per segment).  Then, during matching, the term
 number for each docID is retrieved from the cache and
 then checked for inclusion using the <code>LongBitSet</code>.
 Since all testing is done using RAM resident data
 structures, performance should be very fast, most likely
 fast enough to not require further caching of the
 DocIdSet for each possible combination of terms.
 However, because docIDs are simply scanned linearly, an
 index with a great many small documents may find this
 linear scan too costly.
 <p>
 In contrast, TermsQuery builds up an <code>FixedBitSet</code>,
 keyed by docID, every time it's created, by enumerating
 through all matching docs using <code>org.apache.lucene.index.PostingsEnum</code> to seek
 and scan through each term's docID list.  While there is
 no linear scan of all docIDs, besides the allocation of
 the underlying array in the <code>FixedBitSet</code>, this
 approach requires a number of "disk seeks" in proportion
 to the number of terms, which can be exceptionally costly
 when there are cache misses in the OS's IO cache.
 <p>
 Generally, this filter will be slower on the first
 invocation for a given field, but subsequent invocations,
 even if you change the allowed set of Terms, should be
 faster than TermsQuery, especially as the number of
 Terms being matched increases.  If you are matching only
 a very small number of terms, and those terms in turn
 match a very small number of documents, TermsQuery may
 perform faster.
 <p>
 Which query is best is very application dependent.
 */
@interface OrgApacheLuceneSearchDocValuesTermsQuery : OrgApacheLuceneSearchQuery

#pragma mark Public

- (instancetype)initWithNSString:(NSString *)field
withOrgApacheLuceneUtilBytesRefArray:(IOSObjectArray *)terms;

- (instancetype)initWithNSString:(NSString *)field
          withJavaUtilCollection:(id<JavaUtilCollection>)terms;

- (instancetype)initWithNSString:(NSString *)field
               withNSStringArray:(IOSObjectArray *)terms;

- (OrgApacheLuceneSearchWeight *)createWeightWithOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher
                                                                        withBoolean:(jboolean)needsScores;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

- (NSString *)toStringWithNSString:(NSString *)defaultField;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchDocValuesTermsQuery)

FOUNDATION_EXPORT void OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withJavaUtilCollection_(OrgApacheLuceneSearchDocValuesTermsQuery *self, NSString *field, id<JavaUtilCollection> terms);

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *new_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withJavaUtilCollection_(NSString *field, id<JavaUtilCollection> terms) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *create_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withJavaUtilCollection_(NSString *field, id<JavaUtilCollection> terms);

FOUNDATION_EXPORT void OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withOrgApacheLuceneUtilBytesRefArray_(OrgApacheLuceneSearchDocValuesTermsQuery *self, NSString *field, IOSObjectArray *terms);

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *new_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withOrgApacheLuceneUtilBytesRefArray_(NSString *field, IOSObjectArray *terms) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *create_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withOrgApacheLuceneUtilBytesRefArray_(NSString *field, IOSObjectArray *terms);

FOUNDATION_EXPORT void OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withNSStringArray_(OrgApacheLuceneSearchDocValuesTermsQuery *self, NSString *field, IOSObjectArray *terms);

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *new_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withNSStringArray_(NSString *field, IOSObjectArray *terms) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDocValuesTermsQuery *create_OrgApacheLuceneSearchDocValuesTermsQuery_initWithNSString_withNSStringArray_(NSString *field, IOSObjectArray *terms);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchDocValuesTermsQuery)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchDocValuesTermsQuery")
