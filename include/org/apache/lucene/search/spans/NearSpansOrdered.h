//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchSpansNearSpansOrdered")
#ifdef RESTRICT_OrgApacheLuceneSearchSpansNearSpansOrdered
#define INCLUDE_ALL_OrgApacheLuceneSearchSpansNearSpansOrdered 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchSpansNearSpansOrdered 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchSpansNearSpansOrdered

#if !defined (OrgApacheLuceneSearchSpansNearSpansOrdered_) && (INCLUDE_ALL_OrgApacheLuceneSearchSpansNearSpansOrdered || defined(INCLUDE_OrgApacheLuceneSearchSpansNearSpansOrdered))
#define OrgApacheLuceneSearchSpansNearSpansOrdered_

#define RESTRICT_OrgApacheLuceneSearchSpansNearSpans 1
#define INCLUDE_OrgApacheLuceneSearchSpansNearSpans 1
#include "org/apache/lucene/search/spans/NearSpans.h"

@class OrgApacheLuceneSearchSpansSpanNearQuery;
@protocol JavaUtilList;
@protocol OrgApacheLuceneSearchSpansSpanCollector;

/*!
 @brief A Spans that is formed from the ordered subspans of a SpanNearQuery
 where the subspans do not overlap and have a maximum slop between them.
 <p>
 The formed spans only contains minimum slop matches.<br>
 The matching slop is computed from the distance(s) between
 the non overlapping matching Spans.<br>
 Successive matches are always formed from the successive Spans
 of the SpanNearQuery.
 <p>
 The formed spans may contain overlaps when the slop is at least 1.
 For example, when querying using
 @code
t1 t2 t3
@endcode
 with slop at least 1, the fragment:
 @code
t1 t2 t1 t3 t2 t3
@endcode
 matches twice:
 @code
t1 t2 .. t3      
@endcode
 @code
      t1 .. t2 t3
@endcode
 Expert:
 Only public for subclassing.  Most implementations should not need this class
 */
@interface OrgApacheLuceneSearchSpansNearSpansOrdered : OrgApacheLuceneSearchSpansNearSpans {
 @public
  jint matchStart_;
  jint matchEnd_;
  jint matchWidth_;
}

#pragma mark Public

- (instancetype)initWithOrgApacheLuceneSearchSpansSpanNearQuery:(OrgApacheLuceneSearchSpansSpanNearQuery *)query
                                               withJavaUtilList:(id<JavaUtilList>)subSpans;

- (void)collectWithOrgApacheLuceneSearchSpansSpanCollector:(id<OrgApacheLuceneSearchSpansSpanCollector>)collector;

- (jint)endPosition;

- (jint)nextStartPosition;

- (jint)startPosition;

- (NSString *)description;

- (jint)width;

#pragma mark Package-Private

- (jboolean)twoPhaseCurrentDocMatches;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchSpansNearSpansOrdered)

FOUNDATION_EXPORT void OrgApacheLuceneSearchSpansNearSpansOrdered_initWithOrgApacheLuceneSearchSpansSpanNearQuery_withJavaUtilList_(OrgApacheLuceneSearchSpansNearSpansOrdered *self, OrgApacheLuceneSearchSpansSpanNearQuery *query, id<JavaUtilList> subSpans);

FOUNDATION_EXPORT OrgApacheLuceneSearchSpansNearSpansOrdered *new_OrgApacheLuceneSearchSpansNearSpansOrdered_initWithOrgApacheLuceneSearchSpansSpanNearQuery_withJavaUtilList_(OrgApacheLuceneSearchSpansSpanNearQuery *query, id<JavaUtilList> subSpans) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchSpansNearSpansOrdered *create_OrgApacheLuceneSearchSpansNearSpansOrdered_initWithOrgApacheLuceneSearchSpansSpanNearQuery_withJavaUtilList_(OrgApacheLuceneSearchSpansSpanNearQuery *query, id<JavaUtilList> subSpans);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchSpansNearSpansOrdered)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchSpansNearSpansOrdered")
