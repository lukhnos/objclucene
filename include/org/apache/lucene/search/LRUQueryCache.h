//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/LRUQueryCache.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchLRUQueryCache")
#ifdef RESTRICT_OrgApacheLuceneSearchLRUQueryCache
#define INCLUDE_ALL_OrgApacheLuceneSearchLRUQueryCache 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchLRUQueryCache 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchLRUQueryCache

#if !defined (OrgApacheLuceneSearchLRUQueryCache_) && (INCLUDE_ALL_OrgApacheLuceneSearchLRUQueryCache || defined(INCLUDE_OrgApacheLuceneSearchLRUQueryCache))
#define OrgApacheLuceneSearchLRUQueryCache_

#define RESTRICT_OrgApacheLuceneSearchQueryCache 1
#define INCLUDE_OrgApacheLuceneSearchQueryCache 1
#include "org/apache/lucene/search/QueryCache.h"

#define RESTRICT_OrgApacheLuceneUtilAccountable 1
#define INCLUDE_OrgApacheLuceneUtilAccountable 1
#include "org/apache/lucene/util/Accountable.h"

@class OrgApacheLuceneIndexLeafReader;
@class OrgApacheLuceneIndexLeafReaderContext;
@class OrgApacheLuceneSearchDocIdSet;
@class OrgApacheLuceneSearchDocIdSetIterator;
@class OrgApacheLuceneSearchQuery;
@class OrgApacheLuceneSearchWeight;
@protocol JavaUtilCollection;
@protocol JavaUtilList;
@protocol OrgApacheLuceneSearchQueryCachingPolicy;

/*!
 @brief A <code>QueryCache</code> that evicts queries using a LRU (least-recently-used)
 eviction policy in order to remain under a given maximum size and number of
 bytes used.
 This class is thread-safe.
 Note that query eviction runs in linear time with the total number of
 segments that have cache entries so this cache works best with
 <code>caching policies</code> that only cache on "large"
 segments, and it is advised to not share this cache across too many indices.
 Typical usage looks like this:
 <pre class="prettyprint">
 final int maxNumberOfCachedQueries = 256;
 final long maxRamBytesUsed = 50 * 1024L * 1024L; // 50MB
 // these cache and policy instances can be shared across several queries and readers
 // it is fine to eg. store them into static variables
 final QueryCache queryCache = new LRUQueryCache(maxNumberOfCachedQueries, maxRamBytesUsed);
 final QueryCachingPolicy defaultCachingPolicy = new UsageTrackingQueryCachingPolicy();
 // ...
 // Then at search time
 Query myQuery = ...;
 Query myCacheQuery = queryCache.doCache(myQuery, defaultCachingPolicy);
 // myCacheQuery is now a wrapper around the original query that will interact with the cache
 IndexSearcher searcher = ...;
 TopDocs topDocs = searcher.search(new ConstantScoreQuery(myCacheQuery), 10);
 
@endcode
 This cache exposes some global statistics (<code>hit count</code>,
 <code>miss count</code>, <code>number of cache
 entries</code>
 , <code>total number of DocIdSets that have ever
 been cached</code>
 , <code>number of evicted entries</code>). In
 case you would like to have more fine-grained statistics, such as per-index
 or per-query-class statistics, it is possible to override various callbacks:
 <code>onHit</code>, <code>onMiss</code>,
 <code>onQueryCache</code>, <code>onQueryEviction</code>,
 <code>onDocIdSetCache</code>, <code>onDocIdSetEviction</code> and <code>onClear</code>.
 It is better to not perform heavy computations in these methods though since
 they are called synchronously and under a lock.
 - seealso: QueryCachingPolicy
 */
@interface OrgApacheLuceneSearchLRUQueryCache : NSObject < OrgApacheLuceneSearchQueryCache, OrgApacheLuceneUtilAccountable >

+ (jlong)QUERY_DEFAULT_RAM_BYTES_USED;

+ (jlong)HASHTABLE_RAM_BYTES_PER_ENTRY;

+ (jlong)LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;

#pragma mark Public

/*!
 @brief Create a new instance that will cache at most <code>maxSize</code> queries
 with at most <code>maxRamBytesUsed</code> bytes of memory.
 */
- (instancetype)initWithInt:(jint)maxSize
                   withLong:(jlong)maxRamBytesUsed;

/*!
 @brief Clear the content of this cache.
 */
- (void)clear;

/*!
 @brief Remove all cache entries for the given core cache key.
 */
- (void)clearCoreCacheKeyWithId:(id)coreKey;

/*!
 @brief Remove all cache entries for the given query.
 */
- (void)clearQueryWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

- (OrgApacheLuceneSearchWeight *)doCacheWithOrgApacheLuceneSearchWeight:(OrgApacheLuceneSearchWeight *)weight
                            withOrgApacheLuceneSearchQueryCachingPolicy:(id<OrgApacheLuceneSearchQueryCachingPolicy>)policy;

/*!
 @brief Return the total number of cache entries that have been generated and put
 in the cache.
 It is highly desirable to have a <code>hit
 count</code>
  that is much higher than the <code>cache count</code>
 as the opposite would indicate that the query cache makes efforts in order
 to cache queries but then they do not get reused.
 - seealso: #getCacheSize()
 - seealso: #getEvictionCount()
 */
- (jlong)getCacheCount;

/*!
 @brief Return the total number of <code>DocIdSet</code>s which are currently stored
 in the cache.
 - seealso: #getCacheCount()
 - seealso: #getEvictionCount()
 */
- (jlong)getCacheSize;

- (id<JavaUtilCollection>)getChildResources;

/*!
 @brief Return the number of cache entries that have been removed from the cache
 either in order to stay under the maximum configured size/ram usage, or
 because a segment has been closed.
 High numbers of evictions might mean
 that queries are not reused or that the <code>caching policy</code>
  caches too aggressively on NRT segments which get merged
 early.
 - seealso: #getCacheCount()
 - seealso: #getCacheSize()
 */
- (jlong)getEvictionCount;

/*!
 @brief Over the <code>total</code> number of times that a query has
 been looked up, return how many times a cached <code>DocIdSet</code> has been
 found and returned.
 - seealso: #getTotalCount()
 - seealso: #getMissCount()
 */
- (jlong)getHitCount;

/*!
 @brief Over the <code>total</code> number of times that a query has
 been looked up, return how many times this query was not contained in the
 cache.
 - seealso: #getTotalCount()
 - seealso: #getHitCount()
 */
- (jlong)getMissCount;

/*!
 @brief Return the total number of times that a <code>Query</code> has been looked up
 in this <code>QueryCache</code>.
 Note that this number is incremented once per
 segment so running a cached query only once will increment this counter
 by the number of segments that are wrapped by the searcher.
 Note that by definition, <code>getTotalCount()</code> is the sum of
 <code>getHitCount()</code> and <code>getMissCount()</code>.
 - seealso: #getHitCount()
 - seealso: #getMissCount()
 */
- (jlong)getTotalCount;

- (jlong)ramBytesUsed;

#pragma mark Protected

/*!
 @brief Default cache implementation: uses <code>RoaringDocIdSet</code>.
 */
- (OrgApacheLuceneSearchDocIdSet *)cacheImplWithOrgApacheLuceneSearchDocIdSetIterator:(OrgApacheLuceneSearchDocIdSetIterator *)iterator
                                                   withOrgApacheLuceneIndexLeafReader:(OrgApacheLuceneIndexLeafReader *)reader;

/*!
 @brief Expert: callback when the cache is completely cleared.
 */
- (void)onClear;

/*!
 @brief Expert: callback when a <code>DocIdSet</code> is added to this cache.
 Implementing this method is typically useful in order to compute more
 fine-grained statistics about the query cache.
 - seealso: #onDocIdSetEviction
 */
- (void)onDocIdSetCacheWithId:(id)readerCoreKey
                     withLong:(jlong)ramBytesUsed;

/*!
 @brief Expert: callback when one or more <code>DocIdSet</code>s are removed from this
 cache.
 - seealso: #onDocIdSetCache
 */
- (void)onDocIdSetEvictionWithId:(id)readerCoreKey
                         withInt:(jint)numEntries
                        withLong:(jlong)sumRamBytesUsed;

/*!
 @brief Expert: callback when there is a cache hit on a given query.
 Implementing this method is typically useful in order to compute more
 fine-grained statistics about the query cache.
 - seealso: #onMiss
 */
- (void)onHitWithId:(id)readerCoreKey
withOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

/*!
 @brief Expert: callback when there is a cache miss on a given query.
 - seealso: #onHit
 */
- (void)onMissWithId:(id)readerCoreKey
withOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

/*!
 @brief Expert: callback when a query is added to this cache.
 Implementing this method is typically useful in order to compute more
 fine-grained statistics about the query cache.
 - seealso: #onQueryEviction
 */
- (void)onQueryCacheWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query
                                          withLong:(jlong)ramBytesUsed;

/*!
 @brief Expert: callback when a query is evicted from this cache.
 - seealso: #onQueryCache
 */
- (void)onQueryEvictionWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query
                                             withLong:(jlong)ramBytesUsed;

/*!
 @brief Return the number of bytes used by the given query.
 The default
 implementation returns <code>Accountable.ramBytesUsed()</code> if the query
 implements <code>Accountable</code> and <code>1024</code> otherwise.
 */
- (jlong)ramBytesUsedWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

#pragma mark Package-Private

- (void)assertConsistent;

- (id<JavaUtilList>)cachedQueries;

- (void)evictIfNecessary;

- (OrgApacheLuceneSearchDocIdSet *)getWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)key
                           withOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context;

- (void)putIfAbsentWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query
        withOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context
                withOrgApacheLuceneSearchDocIdSet:(OrgApacheLuceneSearchDocIdSet *)set;

/*!
 @brief Whether evictions are required.
 */
- (jboolean)requiresEviction;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneSearchLRUQueryCache)

inline jlong OrgApacheLuceneSearchLRUQueryCache_get_QUERY_DEFAULT_RAM_BYTES_USED();
#define OrgApacheLuceneSearchLRUQueryCache_QUERY_DEFAULT_RAM_BYTES_USED 192LL
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneSearchLRUQueryCache, QUERY_DEFAULT_RAM_BYTES_USED, jlong)

inline jlong OrgApacheLuceneSearchLRUQueryCache_get_HASHTABLE_RAM_BYTES_PER_ENTRY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jlong OrgApacheLuceneSearchLRUQueryCache_HASHTABLE_RAM_BYTES_PER_ENTRY;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(OrgApacheLuceneSearchLRUQueryCache, HASHTABLE_RAM_BYTES_PER_ENTRY, jlong)

inline jlong OrgApacheLuceneSearchLRUQueryCache_get_LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jlong OrgApacheLuceneSearchLRUQueryCache_LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(OrgApacheLuceneSearchLRUQueryCache, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY, jlong)

FOUNDATION_EXPORT void OrgApacheLuceneSearchLRUQueryCache_initWithInt_withLong_(OrgApacheLuceneSearchLRUQueryCache *self, jint maxSize, jlong maxRamBytesUsed);

FOUNDATION_EXPORT OrgApacheLuceneSearchLRUQueryCache *new_OrgApacheLuceneSearchLRUQueryCache_initWithInt_withLong_(jint maxSize, jlong maxRamBytesUsed) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchLRUQueryCache *create_OrgApacheLuceneSearchLRUQueryCache_initWithInt_withLong_(jint maxSize, jlong maxRamBytesUsed);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchLRUQueryCache)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchLRUQueryCache")
