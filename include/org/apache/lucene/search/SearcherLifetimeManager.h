//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/SearcherLifetimeManager.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager")
#ifdef RESTRICT_OrgApacheLuceneSearchSearcherLifetimeManager
#define INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchSearcherLifetimeManager
#ifdef INCLUDE_OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge
#define INCLUDE_OrgApacheLuceneSearchSearcherLifetimeManager_Pruner 1
#endif

#if !defined (OrgApacheLuceneSearchSearcherLifetimeManager_) && (INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager || defined(INCLUDE_OrgApacheLuceneSearchSearcherLifetimeManager))
#define OrgApacheLuceneSearchSearcherLifetimeManager_

#define RESTRICT_JavaIoCloseable 1
#define INCLUDE_JavaIoCloseable 1
#include "java/io/Closeable.h"

@class OrgApacheLuceneSearchIndexSearcher;
@protocol OrgApacheLuceneSearchSearcherLifetimeManager_Pruner;

/*!
 @brief Keeps track of current plus old IndexSearchers, closing
 the old ones once they have timed out.
 Use it like this:
 <pre class="prettyprint">
 SearcherLifetimeManager mgr = new SearcherLifetimeManager();
 
@endcode
 Per search-request, if it's a "new" search request, then
 obtain the latest searcher you have (for example, by
 using <code>SearcherManager</code>), and then record this
 searcher:
 <pre class="prettyprint">
 // Record the current searcher, and save the returend
 // token into user's search results (eg as a  hidden
 // HTML form field):
 long token = mgr.record(searcher);
 
@endcode
 When a follow-up search arrives, for example the user
 clicks next page, drills down/up, etc., take the token
 that you saved from the previous search and:
 <pre class="prettyprint">
 // If possible, obtain the same searcher as the last
 // search:
 IndexSearcher searcher = mgr.acquire(token);
 if (searcher != null) {
 // Searcher is still here
 try {
 // do searching...
 } finally {
 mgr.release(searcher);
 // Do not use searcher after this!
 searcher = null;
 }
 } else {
 // Searcher was pruned -- notify user session timed
 // out, or, pull fresh searcher again
 }
 
@endcode
 Finally, in a separate thread, ideally the same thread
 that's periodically reopening your searchers, you should
 periodically prune old searchers:
 <pre class="prettyprint">
 mgr.prune(new PruneByAge(600.0));
 
@endcode
 <p><b>NOTE</b>: keeping many searchers around means
 you'll use more resources (open files, RAM) than a single
 searcher.  However, as long as you are using <code>DirectoryReader.openIfChanged(DirectoryReader)</code>
 , the searchers
 will usually share almost all segments and the added resource usage
 is contained.  When a large merge has completed, and
 you reopen, because that is a large change, the new
 searcher will use higher additional RAM than other
 searchers; but large merges don't complete very often and
 it's unlikely you'll hit two of them in your expiration
 window.  Still you should budget plenty of heap in the
 JVM to have a good safety margin.
 */
@interface OrgApacheLuceneSearchSearcherLifetimeManager : NSObject < JavaIoCloseable >

+ (jdouble)NANOS_PER_SEC;

#pragma mark Public

- (instancetype)init;

/*!
 @brief Retrieve a previously recorded <code>IndexSearcher</code>, if it
 has not yet been closed
 <p><b>NOTE</b>: this may return null when the
 requested searcher has already timed out.
 When this
 happens you should notify your user that their session
 timed out and that they'll have to restart their
 search.
 <p>If this returns a non-null result, you must match
 later call <code>release</code> on this searcher, best
 from a finally clause. 
 */
- (OrgApacheLuceneSearchIndexSearcher *)acquireWithLong:(jlong)version_;

/*!
 @brief Close this to future searching; any searches still in
 process in other threads won't be affected, and they
 should still call <code>release</code> after they are
 done.
 <p><b>NOTE</b>: you must ensure no other threads are
 calling <code>record</code> while you call close();
 otherwise it's possible not all searcher references
 will be freed. 
 */
- (void)close;

/*!
 @brief Calls provided <code>Pruner</code> to prune entries.
 The
 entries are passed to the Pruner in sorted (newest to
 oldest IndexSearcher) order.
 <p><b>NOTE</b>: you must peridiocally call this, ideally
 from the same background thread that opens new
 searchers. 
 */
- (void)pruneWithOrgApacheLuceneSearchSearcherLifetimeManager_Pruner:(id<OrgApacheLuceneSearchSearcherLifetimeManager_Pruner>)pruner;

/*!
 @brief Records that you are now using this IndexSearcher.
 Always call this when you've obtained a possibly new
 <code>IndexSearcher</code>, for example from <code>SearcherManager</code>
 .  It's fine if you already passed the
 same searcher to this method before.
 <p>This returns the long token that you can later pass
 to <code>acquire</code> to retrieve the same IndexSearcher.
 You should record this long token in the search results
 sent to your user, such that if the user performs a
 follow-on action (clicks next page, drills down, etc.)
 the token is returned. 
 */
- (jlong)recordWithOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher;

/*!
 @brief Release a searcher previously obtained from <code>acquire</code>
 .
 <p><b>NOTE</b>: it's fine to call this after close. 
 */
- (void)release__WithOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)s;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchSearcherLifetimeManager)

inline jdouble OrgApacheLuceneSearchSearcherLifetimeManager_get_NANOS_PER_SEC();
#define OrgApacheLuceneSearchSearcherLifetimeManager_NANOS_PER_SEC 1.0E9
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneSearchSearcherLifetimeManager, NANOS_PER_SEC, jdouble)

FOUNDATION_EXPORT void OrgApacheLuceneSearchSearcherLifetimeManager_init(OrgApacheLuceneSearchSearcherLifetimeManager *self);

FOUNDATION_EXPORT OrgApacheLuceneSearchSearcherLifetimeManager *new_OrgApacheLuceneSearchSearcherLifetimeManager_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchSearcherLifetimeManager *create_OrgApacheLuceneSearchSearcherLifetimeManager_init();

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchSearcherLifetimeManager)

#endif

#if !defined (OrgApacheLuceneSearchSearcherLifetimeManager_Pruner_) && (INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager || defined(INCLUDE_OrgApacheLuceneSearchSearcherLifetimeManager_Pruner))
#define OrgApacheLuceneSearchSearcherLifetimeManager_Pruner_

@class OrgApacheLuceneSearchIndexSearcher;

/*!
 @brief See <code>prune</code>.
 */
@protocol OrgApacheLuceneSearchSearcherLifetimeManager_Pruner < NSObject, JavaObject >

/*!
 @brief Return true if this searcher should be removed.
 @param ageSec how much time has passed since this
 searcher was the current (live) searcher
 @param searcher Searcher
 */
- (jboolean)doPruneWithDouble:(jdouble)ageSec
withOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchSearcherLifetimeManager_Pruner)

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchSearcherLifetimeManager_Pruner)

#endif

#if !defined (OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge_) && (INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager || defined(INCLUDE_OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge))
#define OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge_

@class OrgApacheLuceneSearchIndexSearcher;

/*!
 @brief Simple pruner that drops any searcher older by
 more than the specified seconds, than the newest
 searcher.
 */
@interface OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge : NSObject < OrgApacheLuceneSearchSearcherLifetimeManager_Pruner >

#pragma mark Public

- (instancetype)initWithDouble:(jdouble)maxAgeSec;

- (jboolean)doPruneWithDouble:(jdouble)ageSec
withOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge)

FOUNDATION_EXPORT void OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge_initWithDouble_(OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge *self, jdouble maxAgeSec);

FOUNDATION_EXPORT OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge *new_OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge_initWithDouble_(jdouble maxAgeSec) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge *create_OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge_initWithDouble_(jdouble maxAgeSec);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchSearcherLifetimeManager_PruneByAge)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchSearcherLifetimeManager")
