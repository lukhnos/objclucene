//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery")
#ifdef RESTRICT_OrgApacheLuceneSearchDisjunctionMaxQuery
#define INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchDisjunctionMaxQuery

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheLuceneSearchDisjunctionMaxQuery_) && (INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery || defined(INCLUDE_OrgApacheLuceneSearchDisjunctionMaxQuery))
#define OrgApacheLuceneSearchDisjunctionMaxQuery_

#define RESTRICT_OrgApacheLuceneSearchQuery 1
#define INCLUDE_OrgApacheLuceneSearchQuery 1
#include "org/apache/lucene/search/Query.h"

#define RESTRICT_JavaLangIterable 1
#define INCLUDE_JavaLangIterable 1
#include "java/lang/Iterable.h"

@class JavaUtilArrayList;
@class OrgApacheLuceneIndexIndexReader;
@class OrgApacheLuceneSearchIndexSearcher;
@class OrgApacheLuceneSearchWeight;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
  score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
 This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
  combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
  not the sum of the field scores (as BooleanQuery would give).
  If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
  another gets a higher score than "albino" matching both fields.
  To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
  each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
  The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
  include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
  in the multiple fields.
 */
@interface OrgApacheLuceneSearchDisjunctionMaxQuery : OrgApacheLuceneSearchQuery < JavaLangIterable >

#pragma mark Public

/*!
 @brief Creates a new DisjunctionMaxQuery
 @param disjuncts a <code>Collection<Query></code>  of all the disjuncts to add
 @param tieBreakerMultiplier the weight to give to each matching non-maximum disjunct
 */
- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)disjuncts
                                           withFloat:(jfloat)tieBreakerMultiplier;

/*!
 @brief Creates a new empty DisjunctionMaxQuery.Use add() to add the subqueries.
 @param tieBreakerMultiplier the score of each non-maximum disjunct for a document is multiplied by this weight         and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
          10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
          word in the lower scored field (i.e., one that is not in any higher scored field.
 */
- (instancetype __nonnull)initWithFloat:(jfloat)tieBreakerMultiplier;

/*!
 @brief Add a collection of disjuncts to this disjunction
  via <code>Iterable<Query></code>
 @param disjuncts a collection of queries to add as disjuncts.
 */
- (void)addWithJavaUtilCollection:(id<JavaUtilCollection>)disjuncts;

/*!
 @brief Add a subquery to this disjunction
 @param query the disjunct added
 */
- (void)addWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

/*!
 @brief Create a shallow copy of us -- used in rewriting if necessary
 @return a copy of us (but reuse, don't copy, our subqueries)
 */
- (OrgApacheLuceneSearchDisjunctionMaxQuery *)java_clone;

/*!
 @brief Create the Weight used to score us
 */
- (OrgApacheLuceneSearchWeight *)createWeightWithOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher
                                                                        withBoolean:(jboolean)needsScores;

/*!
 @brief Return true iff we represent the same query as o
 @param o another object
 @return true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us
 */
- (jboolean)isEqual:(id)o;

/*!
 @return the disjuncts.
 */
- (JavaUtilArrayList *)getDisjuncts;

/*!
 @return tie breaker value for multiple matches.
 */
- (jfloat)getTieBreakerMultiplier;

/*!
 @brief Compute a hash code for hashing us
 @return the hash code
 */
- (NSUInteger)hash;

/*!
 @return An <code>Iterator<Query></code> over the disjuncts
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Optimize our representation and our subqueries representations
 @param reader the IndexReader we query
 @return an optimized copy of us (which may not be a copy if there is nothing to optimize)
 */
- (OrgApacheLuceneSearchQuery *)rewriteWithOrgApacheLuceneIndexIndexReader:(OrgApacheLuceneIndexIndexReader *)reader;

/*!
 @brief Prettyprint us.
 @param field the field to which we are applied
 @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
 */
- (NSString *)toStringWithNSString:(NSString *)field;

#pragma mark Package-Private

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchDisjunctionMaxQuery)

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(OrgApacheLuceneSearchDisjunctionMaxQuery *self, jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *new_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(jfloat tieBreakerMultiplier) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *create_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(OrgApacheLuceneSearchDisjunctionMaxQuery *self, id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *new_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *create_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchDisjunctionMaxQuery)

#endif

#if !defined (OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_) && (INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery || defined(INCLUDE_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight))
#define OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_

#define RESTRICT_OrgApacheLuceneSearchWeight 1
#define INCLUDE_OrgApacheLuceneSearchWeight 1
#include "org/apache/lucene/search/Weight.h"

@class JavaUtilArrayList;
@class OrgApacheLuceneIndexLeafReaderContext;
@class OrgApacheLuceneSearchDisjunctionMaxQuery;
@class OrgApacheLuceneSearchExplanation;
@class OrgApacheLuceneSearchIndexSearcher;
@class OrgApacheLuceneSearchQuery;
@class OrgApacheLuceneSearchScorer;
@protocol JavaUtilSet;

/*!
 @brief Expert: the Weight for DisjunctionMaxQuery, used to
  normalize, score and explain these queries.
 <p>NOTE: this API and implementation is subject to
  change suddenly in the next release.</p>
 */
@interface OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight : OrgApacheLuceneSearchWeight {
 @public
  /*!
   @brief The Weights for our subqueries, in 1-1 correspondence with disjuncts
   */
  JavaUtilArrayList *weights_;
}

#pragma mark Public

/*!
 @brief Construct the Weight for this Query searched by searcher.Recursively construct subquery weights.
 */
- (instancetype __nonnull)initWithOrgApacheLuceneSearchDisjunctionMaxQuery:(OrgApacheLuceneSearchDisjunctionMaxQuery *)outer$
                                    withOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher
                                                               withBoolean:(jboolean)needsScores;

/*!
 @brief Explain the score we computed for doc
 */
- (OrgApacheLuceneSearchExplanation *)explainWithOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context
                                                                               withInt:(jint)doc;

- (void)extractTermsWithJavaUtilSet:(id<JavaUtilSet>)terms;

/*!
 @brief Compute the sub of squared weights of us applied to our subqueries.Used for normalization.
 */
- (jfloat)getValueForNormalization;

/*!
 @brief Apply the computed normalization factor to our subqueries
 */
- (void)normalizeWithFloat:(jfloat)norm
                 withFloat:(jfloat)topLevelBoost;

/*!
 @brief Create the scorer used to score our associated DisjunctionMaxQuery
 */
- (OrgApacheLuceneSearchScorer *)scorerWithOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight)

J2OBJC_FIELD_SETTER(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight, weights_, JavaUtilArrayList *)

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *self, OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *new_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *create_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery")
