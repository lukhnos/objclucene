//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery")
#ifdef RESTRICT_OrgApacheLuceneSearchDisjunctionMaxQuery
#define INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery 0
#else
#define INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery 1
#endif
#undef RESTRICT_OrgApacheLuceneSearchDisjunctionMaxQuery

#if !defined (OrgApacheLuceneSearchDisjunctionMaxQuery_) && (INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery || defined(INCLUDE_OrgApacheLuceneSearchDisjunctionMaxQuery))
#define OrgApacheLuceneSearchDisjunctionMaxQuery_

#define RESTRICT_OrgApacheLuceneSearchQuery 1
#define INCLUDE_OrgApacheLuceneSearchQuery 1
#include "org/apache/lucene/search/Query.h"

#define RESTRICT_JavaLangIterable 1
#define INCLUDE_JavaLangIterable 1
#include "java/lang/Iterable.h"

@class JavaUtilArrayList;
@class OrgApacheLuceneIndexIndexReader;
@class OrgApacheLuceneSearchIndexSearcher;
@class OrgApacheLuceneSearchWeight;
@protocol JavaUtilCollection;
@protocol JavaUtilIterator;

/*!
 @brief A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
 score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
 This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
 combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
 not the sum of the field scores (as BooleanQuery would give).
 If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
 another gets a higher score than "albino" matching both fields.
 To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
 each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
 The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
 include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
 in the multiple fields.
 */
@interface OrgApacheLuceneSearchDisjunctionMaxQuery : OrgApacheLuceneSearchQuery < JavaLangIterable >

#pragma mark Public

/*!
 @brief Creates a new DisjunctionMaxQuery
 @param disjuncts a <code>Collection<Query></code> of all the disjuncts to add
 @param tieBreakerMultiplier   the weight to give to each matching non-maximum disjunct
 */
- (instancetype)initWithJavaUtilCollection:(id<JavaUtilCollection>)disjuncts
                                 withFloat:(jfloat)tieBreakerMultiplier;

/*!
 @brief Creates a new empty DisjunctionMaxQuery.
 Use add() to add the subqueries.
 @param tieBreakerMultiplier the score of each non-maximum disjunct for a document is multiplied by this weight
 and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
 10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
 word in the lower scored field (i.e., one that is not in any higher scored field.
 */
- (instancetype)initWithFloat:(jfloat)tieBreakerMultiplier;

/*!
 @brief Add a collection of disjuncts to this disjunction
 via <code>Iterable<Query></code>
 @param disjuncts a collection of queries to add as disjuncts.
 */
- (void)addWithJavaUtilCollection:(id<JavaUtilCollection>)disjuncts;

/*!
 @brief Add a subquery to this disjunction
 @param query the disjunct added
 */
- (void)addWithOrgApacheLuceneSearchQuery:(OrgApacheLuceneSearchQuery *)query;

/*!
 @brief Create a shallow copy of us -- used in rewriting if necessary
 @return a copy of us (but reuse, don't copy, our subqueries)
 */
- (OrgApacheLuceneSearchDisjunctionMaxQuery *)clone;

/*!
 @brief Create the Weight used to score us
 */
- (OrgApacheLuceneSearchWeight *)createWeightWithOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher
                                                                        withBoolean:(jboolean)needsScores;

/*!
 @brief Return true iff we represent the same query as o
 @param o another object
 @return true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us
 */
- (jboolean)isEqual:(id)o;

/*!
 @return the disjuncts.
 */
- (JavaUtilArrayList *)getDisjuncts;

/*!
 @return tie breaker value for multiple matches.
 */
- (jfloat)getTieBreakerMultiplier;

/*!
 @brief Compute a hash code for hashing us
 @return the hash code
 */
- (NSUInteger)hash;

/*!
 @return An <code>Iterator<Query></code> over the disjuncts
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Optimize our representation and our subqueries representations
 @param reader the IndexReader we query
 @return an optimized copy of us (which may not be a copy if there is nothing to optimize)
 */
- (OrgApacheLuceneSearchQuery *)rewriteWithOrgApacheLuceneIndexIndexReader:(OrgApacheLuceneIndexIndexReader *)reader;

/*!
 @brief Prettyprint us.
 @param field the field to which we are applied
 @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
 */
- (NSString *)toStringWithNSString:(NSString *)field;

#pragma mark Package-Private

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchDisjunctionMaxQuery)

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(OrgApacheLuceneSearchDisjunctionMaxQuery *self, jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *new_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(jfloat tieBreakerMultiplier) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *create_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithFloat_(jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(OrgApacheLuceneSearchDisjunctionMaxQuery *self, id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *new_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery *create_OrgApacheLuceneSearchDisjunctionMaxQuery_initWithJavaUtilCollection_withFloat_(id<JavaUtilCollection> disjuncts, jfloat tieBreakerMultiplier);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchDisjunctionMaxQuery)

#endif

#if !defined (OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_) && (INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery || defined(INCLUDE_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight))
#define OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_

#define RESTRICT_OrgApacheLuceneSearchWeight 1
#define INCLUDE_OrgApacheLuceneSearchWeight 1
#include "org/apache/lucene/search/Weight.h"

@class JavaUtilArrayList;
@class OrgApacheLuceneIndexLeafReaderContext;
@class OrgApacheLuceneSearchDisjunctionMaxQuery;
@class OrgApacheLuceneSearchExplanation;
@class OrgApacheLuceneSearchIndexSearcher;
@class OrgApacheLuceneSearchScorer;
@protocol JavaUtilSet;

/*!
 @brief Expert: the Weight for DisjunctionMaxQuery, used to
 normalize, score and explain these queries.
 <p>NOTE: this API and implementation is subject to
 change suddenly in the next release.</p>
 */
@interface OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight : OrgApacheLuceneSearchWeight {
 @public
  /*!
   @brief The Weights for our subqueries, in 1-1 correspondence with disjuncts
   */
  JavaUtilArrayList *weights_;
}

#pragma mark Public

/*!
 @brief Construct the Weight for this Query searched by searcher.
 Recursively construct subquery weights. 
 */
- (instancetype)initWithOrgApacheLuceneSearchDisjunctionMaxQuery:(OrgApacheLuceneSearchDisjunctionMaxQuery *)outer$
                          withOrgApacheLuceneSearchIndexSearcher:(OrgApacheLuceneSearchIndexSearcher *)searcher
                                                     withBoolean:(jboolean)needsScores;

/*!
 @brief Explain the score we computed for doc
 */
- (OrgApacheLuceneSearchExplanation *)explainWithOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context
                                                                               withInt:(jint)doc;

- (void)extractTermsWithJavaUtilSet:(id<JavaUtilSet>)terms;

/*!
 @brief Compute the sub of squared weights of us applied to our subqueries.
 Used for normalization. 
 */
- (jfloat)getValueForNormalization;

/*!
 @brief Apply the computed normalization factor to our subqueries
 */
- (void)normalizeWithFloat:(jfloat)norm
                 withFloat:(jfloat)topLevelBoost;

/*!
 @brief Create the scorer used to score our associated DisjunctionMaxQuery
 */
- (OrgApacheLuceneSearchScorer *)scorerWithOrgApacheLuceneIndexLeafReaderContext:(OrgApacheLuceneIndexLeafReaderContext *)context;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight)

J2OBJC_FIELD_SETTER(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight, weights_, JavaUtilArrayList *)

FOUNDATION_EXPORT void OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *self, OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores);

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *new_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight *create_OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight_initWithOrgApacheLuceneSearchDisjunctionMaxQuery_withOrgApacheLuceneSearchIndexSearcher_withBoolean_(OrgApacheLuceneSearchDisjunctionMaxQuery *outer$, OrgApacheLuceneSearchIndexSearcher *searcher, jboolean needsScores);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneSearchDisjunctionMaxQuery_DisjunctionMaxWeight)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneSearchDisjunctionMaxQuery")
