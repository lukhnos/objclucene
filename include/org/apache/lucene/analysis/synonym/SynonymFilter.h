//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneAnalysisSynonymSynonymFilter")
#ifdef RESTRICT_OrgApacheLuceneAnalysisSynonymSynonymFilter
#define INCLUDE_ALL_OrgApacheLuceneAnalysisSynonymSynonymFilter 0
#else
#define INCLUDE_ALL_OrgApacheLuceneAnalysisSynonymSynonymFilter 1
#endif
#undef RESTRICT_OrgApacheLuceneAnalysisSynonymSynonymFilter

#if !defined (OrgApacheLuceneAnalysisSynonymSynonymFilter_) && (INCLUDE_ALL_OrgApacheLuceneAnalysisSynonymSynonymFilter || defined(INCLUDE_OrgApacheLuceneAnalysisSynonymSynonymFilter))
#define OrgApacheLuceneAnalysisSynonymSynonymFilter_

#define RESTRICT_OrgApacheLuceneAnalysisTokenFilter 1
#define INCLUDE_OrgApacheLuceneAnalysisTokenFilter 1
#include "org/apache/lucene/analysis/TokenFilter.h"

@class OrgApacheLuceneAnalysisSynonymSynonymMap;
@class OrgApacheLuceneAnalysisTokenStream;

/*!
 @brief Matches single or multi word synonyms in a token stream.
 This token stream cannot properly handle position
 increments != 1, ie, you should place this filter before
 filtering out stop words.
 <p>Note that with the current implementation, parsing is
 greedy, so whenever multiple parses would apply, the rule
 starting the earliest and parsing the most tokens wins.
 For example if you have these rules:
 @code

   a -&gt; x
   a b -&gt; y
   b c d -&gt; z
  
@endcode
 Then input <code>a b c d e</code> parses to <code>y b c
 d</code>, ie the 2nd rule "wins" because it started
 earliest and matched the most input tokens of other rules
 starting at that point.
 <p>A future improvement to this filter could allow
 non-greedy parsing, such that the 3rd rule would win, and
 also separately allow multiple parses, such that all 3
 rules would match, perhaps even on a rule by rule
 basis.</p>
 <p><b>NOTE</b>: when a match occurs, the output tokens
 associated with the matching rule are "stacked" on top of
 the input stream (if the rule had
 <code>keepOrig=true</code>) and also on top of another
 matched rule's output tokens.  This is not a correct
 solution, as really the output should be an arbitrary
 graph/lattice.  For example, with the above match, you
 would expect an exact <code>PhraseQuery</code> <code>"y b
 c"</code> to match the parsed tokens, but it will fail to
 do so.  This limitation is necessary because Lucene's
 TokenStream (and index) cannot yet represent an arbitrary
 graph.</p>
 <p><b>NOTE</b>: If multiple incoming tokens arrive on the
 same position, only the first token at that position is
 used for parsing.  Subsequent tokens simply pass through
 and are not parsed.  A future improvement would be to
 allow these tokens to also be matched.</p>
 */
@interface OrgApacheLuceneAnalysisSynonymSynonymFilter : OrgApacheLuceneAnalysisTokenFilter

+ (NSString *)TYPE_SYNONYM;

#pragma mark Public

/*!
 @param input input tokenstream
 @param synonyms synonym map
 @param ignoreCase case-folds input for matching with <code>Character.toLowerCase(int)</code>.
 Note, if you set this to true, it's your responsibility to lowercase
 the input entries when you create the <code>SynonymMap</code>
 */
- (instancetype)initWithOrgApacheLuceneAnalysisTokenStream:(OrgApacheLuceneAnalysisTokenStream *)input
              withOrgApacheLuceneAnalysisSynonymSynonymMap:(OrgApacheLuceneAnalysisSynonymSynonymMap *)synonyms
                                               withBoolean:(jboolean)ignoreCase;

- (jboolean)incrementToken;

- (void)reset;

#pragma mark Package-Private

- (jint)getCaptureCount;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneAnalysisSynonymSynonymFilter)

inline NSString *OrgApacheLuceneAnalysisSynonymSynonymFilter_get_TYPE_SYNONYM();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheLuceneAnalysisSynonymSynonymFilter_TYPE_SYNONYM;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneAnalysisSynonymSynonymFilter, TYPE_SYNONYM, NSString *)

FOUNDATION_EXPORT void OrgApacheLuceneAnalysisSynonymSynonymFilter_initWithOrgApacheLuceneAnalysisTokenStream_withOrgApacheLuceneAnalysisSynonymSynonymMap_withBoolean_(OrgApacheLuceneAnalysisSynonymSynonymFilter *self, OrgApacheLuceneAnalysisTokenStream *input, OrgApacheLuceneAnalysisSynonymSynonymMap *synonyms, jboolean ignoreCase);

FOUNDATION_EXPORT OrgApacheLuceneAnalysisSynonymSynonymFilter *new_OrgApacheLuceneAnalysisSynonymSynonymFilter_initWithOrgApacheLuceneAnalysisTokenStream_withOrgApacheLuceneAnalysisSynonymSynonymMap_withBoolean_(OrgApacheLuceneAnalysisTokenStream *input, OrgApacheLuceneAnalysisSynonymSynonymMap *synonyms, jboolean ignoreCase) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneAnalysisSynonymSynonymFilter *create_OrgApacheLuceneAnalysisSynonymSynonymFilter_initWithOrgApacheLuceneAnalysisTokenStream_withOrgApacheLuceneAnalysisSynonymSynonymMap_withBoolean_(OrgApacheLuceneAnalysisTokenStream *input, OrgApacheLuceneAnalysisSynonymSynonymMap *synonyms, jboolean ignoreCase);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneAnalysisSynonymSynonymFilter)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneAnalysisSynonymSynonymFilter")
