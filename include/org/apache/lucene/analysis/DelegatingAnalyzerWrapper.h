//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/analysis/DelegatingAnalyzerWrapper.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper")
#ifdef RESTRICT_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper
#define INCLUDE_ALL_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper 0
#else
#define INCLUDE_ALL_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper 1
#endif
#undef RESTRICT_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper

#if !defined (OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper_) && (INCLUDE_ALL_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper || defined(INCLUDE_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper))
#define OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper_

#define RESTRICT_OrgApacheLuceneAnalysisAnalyzerWrapper 1
#define INCLUDE_OrgApacheLuceneAnalysisAnalyzerWrapper 1
#include "org/apache/lucene/analysis/AnalyzerWrapper.h"

@class JavaIoReader;
@class OrgApacheLuceneAnalysisAnalyzer_ReuseStrategy;
@class OrgApacheLuceneAnalysisAnalyzer_TokenStreamComponents;

/*!
 @brief An analyzer wrapper, that doesn't allow to wrap components or readers.
 By disallowing it, it means that the thread local resources can be delegated
 to the delegate analyzer, and not also be allocated on this analyzer.
 This wrapper class is the base class of all analyzers that just delegate to
 another analyzer, e.g. per field name.
 <p>This solves the problem of per field analyzer wrapper, where it also
 maintains a thread local per field token stream components, while it can
 safely delegate those and not also hold these data structures, which can
 become expensive memory wise.
 <p><b>Please note:</b> This analyzer uses a private <code>Analyzer.ReuseStrategy</code>,
 which is returned by <code>getReuseStrategy()</code>. This strategy is used when
 delegating. If you wrap this analyzer again and reuse this strategy, no
 delegation is done and the given fallback is used.
 */
@interface OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper : OrgApacheLuceneAnalysisAnalyzerWrapper

#pragma mark Protected

/*!
 @brief Constructor.
 @param fallbackStrategy is the strategy to use if delegation is not possible
 This is to support the common pattern:
 <code>new OtherWrapper(thisWrapper.getReuseStrategy())</code>
 */
- (instancetype)initWithOrgApacheLuceneAnalysisAnalyzer_ReuseStrategy:(OrgApacheLuceneAnalysisAnalyzer_ReuseStrategy *)fallbackStrategy;

- (OrgApacheLuceneAnalysisAnalyzer_TokenStreamComponents *)wrapComponentsWithNSString:(NSString *)fieldName
                            withOrgApacheLuceneAnalysisAnalyzer_TokenStreamComponents:(OrgApacheLuceneAnalysisAnalyzer_TokenStreamComponents *)components;

- (JavaIoReader *)wrapReaderWithNSString:(NSString *)fieldName
                        withJavaIoReader:(JavaIoReader *)reader;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper)

FOUNDATION_EXPORT void OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper_initWithOrgApacheLuceneAnalysisAnalyzer_ReuseStrategy_(OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper *self, OrgApacheLuceneAnalysisAnalyzer_ReuseStrategy *fallbackStrategy);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneAnalysisDelegatingAnalyzerWrapper")
