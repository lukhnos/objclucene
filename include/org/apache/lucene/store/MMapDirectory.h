//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/store/MMapDirectory.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneStoreMMapDirectory")
#ifdef RESTRICT_OrgApacheLuceneStoreMMapDirectory
#define INCLUDE_ALL_OrgApacheLuceneStoreMMapDirectory 0
#else
#define INCLUDE_ALL_OrgApacheLuceneStoreMMapDirectory 1
#endif
#undef RESTRICT_OrgApacheLuceneStoreMMapDirectory

#if !defined (OrgApacheLuceneStoreMMapDirectory_) && (INCLUDE_ALL_OrgApacheLuceneStoreMMapDirectory || defined(INCLUDE_OrgApacheLuceneStoreMMapDirectory))
#define OrgApacheLuceneStoreMMapDirectory_

#define RESTRICT_OrgApacheLuceneStoreFSDirectory 1
#define INCLUDE_OrgApacheLuceneStoreFSDirectory 1
#include "org/apache/lucene/store/FSDirectory.h"

@class IOSObjectArray;
@class JavaNioChannelsFileChannel;
@class OrgApacheLuceneStoreIOContext;
@class OrgApacheLuceneStoreIndexInput;
@class OrgApacheLuceneStoreLockFactory;
@class OrgLukhnosPortmobileFilePath;

/*!
 @brief File-based <code>Directory</code> implementation that uses
 mmap for reading, and <code>FSDirectory.FSIndexOutput</code>
  for writing.
 <p><b>NOTE</b>: memory mapping uses up a portion of the
 virtual memory address space in your process equal to the
 size of the file being mapped.  Before using this class,
 be sure your have plenty of virtual address space, e.g. by
 using a 64 bit JRE, or a 32 bit JRE with indexes that are
 guaranteed to fit within the address space.
 On 32 bit platforms also consult <code>MMapDirectory(Path,LockFactory,int)</code>
 if you have problems with mmap failing because of fragmented
 address space. If you get an OutOfMemoryException, it is recommended
 to reduce the chunk size, until it works.
 <p>Due to <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038">
 this bug</a> in Sun's JRE, MMapDirectory's <code>IndexInput.close</code>
 is unable to close the underlying OS file handle.  Only when GC
 finally collects the underlying objects, which could be quite
 some time later, will the file handle be closed.
 <p>This will consume additional transient disk usage: on Windows,
 attempts to delete or overwrite the files will result in an
 exception; on other platforms, which typically have a &quot;delete on
 last close&quot; semantics, while such operations will succeed, the bytes
 are still consuming space on disk.  For many applications this
 limitation is not a problem (e.g. if you have plenty of disk space,
 and you don't rely on overwriting files on Windows) but it's still
 an important limitation to be aware of.
 <p>This class supplies the workaround mentioned in the bug report
 (see <code>setUseUnmap</code>), which may fail on
 non-Sun JVMs. It forcefully unmaps the buffer on close by using
 an undocumented internal cleanup functionality. If
 <code>UNMAP_SUPPORTED</code> is <code>true</code>, the workaround
 will be automatically enabled (with no guarantees; if you discover
 any problems, you can disable it).
 <p>
 <b>NOTE:</b> Accessing this class either directly or
 indirectly from a thread while it's interrupted can close the
 underlying channel immediately if at the same time the thread is
 blocked on IO. The channel will remain closed and subsequent access
 to <code>MMapDirectory</code> will throw a <code>ClosedChannelException</code>. If
 your application uses either <code>Thread.interrupt()</code> or
 <code>Future.cancel(boolean)</code> you should use the legacy <code>RAFDirectory</code>
 from the Lucene <code>misc</code> module in favor of <code>MMapDirectory</code>.
 </p>
 - seealso: <a href="http://blog.thetaphi.de/2012/07/use-lucenes-mmapdirectory-on-64bit.html">Blog post about MMapDirectory</a>
 */
@interface OrgApacheLuceneStoreMMapDirectory : OrgApacheLuceneStoreFSDirectory {
 @public
  jint chunkSizePower_;
}

+ (jint)DEFAULT_MAX_CHUNK_SIZE;

+ (jboolean)UNMAP_SUPPORTED;

#pragma mark Public

/*!
 @brief Create a new MMapDirectory for the named location and <code>FSLockFactory.getDefault()</code>.
 The directory is created at the named location if it does not yet exist.
 @param path the path of the directory
 @throws IOException if there is a low-level I/O error
 */
- (instancetype)initWithOrgLukhnosPortmobileFilePath:(OrgLukhnosPortmobileFilePath *)path;

/*!
 @brief Create a new MMapDirectory for the named location and <code>FSLockFactory.getDefault()</code>.
 The directory is created at the named location if it does not yet exist.
 @param path the path of the directory
 @param maxChunkSize maximum chunk size (default is 1 GiBytes for
 64 bit JVMs and 256 MiBytes for 32 bit JVMs) used for memory mapping.
 @throws IOException if there is a low-level I/O error
 */
- (instancetype)initWithOrgLukhnosPortmobileFilePath:(OrgLukhnosPortmobileFilePath *)path
                                             withInt:(jint)maxChunkSize;

/*!
 @brief Create a new MMapDirectory for the named location.
 The directory is created at the named location if it does not yet exist.
 @param path the path of the directory
 @param lockFactory the lock factory to use
 @throws IOException if there is a low-level I/O error
 */
- (instancetype)initWithOrgLukhnosPortmobileFilePath:(OrgLukhnosPortmobileFilePath *)path
                 withOrgApacheLuceneStoreLockFactory:(OrgApacheLuceneStoreLockFactory *)lockFactory;

/*!
 @brief Create a new MMapDirectory for the named location, specifying the 
 maximum chunk size used for memory mapping.
 The directory is created at the named location if it does not yet exist.
 @param path the path of the directory
 @param lockFactory the lock factory to use, or null for the default
 (<code>NativeFSLockFactory</code>);
 @param maxChunkSize maximum chunk size (default is 1 GiBytes for
 64 bit JVMs and 256 MiBytes for 32 bit JVMs) used for memory mapping.
 <p>
 Especially on 32 bit platform, the address space can be very fragmented,
 so large index files cannot be mapped. Using a lower chunk size makes 
 the directory implementation a little bit slower (as the correct chunk 
 may be resolved on lots of seeks) but the chance is higher that mmap 
 does not fail. On 64 bit Java platforms, this parameter should always 
 be <code>1 << 30</code>, as the address space is big enough.
 <p>
 <b>Please note:</b> The chunk size is always rounded down to a power of 2.
 @throws IOException if there is a low-level I/O error
 */
- (instancetype)initWithOrgLukhnosPortmobileFilePath:(OrgLukhnosPortmobileFilePath *)path
                 withOrgApacheLuceneStoreLockFactory:(OrgApacheLuceneStoreLockFactory *)lockFactory
                                             withInt:(jint)maxChunkSize;

/*!
 @brief Returns the current mmap chunk size.
 - seealso: #MMapDirectory(Path,LockFactory,int)
 */
- (jint)getMaxChunkSize;

/*!
 @brief Returns <code>true</code> if mapped pages should be loaded.
 - seealso: #setPreload
 */
- (jboolean)getPreload;

/*!
 @brief Returns <code>true</code>, if the unmap workaround is enabled.
 - seealso: #setUseUnmap
 */
- (jboolean)getUseUnmap;

/*!
 @brief Creates an IndexInput for the file with the given name.
 */
- (OrgApacheLuceneStoreIndexInput *)openInputWithNSString:(NSString *)name
                        withOrgApacheLuceneStoreIOContext:(OrgApacheLuceneStoreIOContext *)context;

/*!
 @brief Set to <code>true</code> to ask mapped pages to be loaded
 into physical memory on init.
 The behavior is best-effort 
 and operating system dependent.
 - seealso: MappedByteBuffer#load
 */
- (void)setPreloadWithBoolean:(jboolean)preload;

/*!
 @brief This method enables the workaround for unmapping the buffers
 from address space after closing <code>IndexInput</code>, that is
 mentioned in the bug report.
 This hack may fail on non-Sun JVMs.
 It forcefully unmaps the buffer on close by using
 an undocumented internal cleanup functionality.
 <p><b>NOTE:</b> Enabling this is completely unsupported
 by Java and may lead to JVM crashes if <code>IndexInput</code>
 is closed while another thread is still accessing it (SIGSEGV).
 @throws IllegalArgumentException if <code>UNMAP_SUPPORTED</code>
 is <code>false</code> and the workaround cannot be enabled.
 */
- (void)setUseUnmapWithBoolean:(jboolean)useUnmapHack;

#pragma mark Package-Private

/*!
 @brief Maps a file into a set of buffers
 */
- (IOSObjectArray *)mapWithNSString:(NSString *)resourceDescription
     withJavaNioChannelsFileChannel:(JavaNioChannelsFileChannel *)fc
                           withLong:(jlong)offset
                           withLong:(jlong)length;

@end

J2OBJC_STATIC_INIT(OrgApacheLuceneStoreMMapDirectory)

/*!
 @brief Default max chunk size.
 - seealso: #MMapDirectory(Path,LockFactory,int)
 */
inline jint OrgApacheLuceneStoreMMapDirectory_get_DEFAULT_MAX_CHUNK_SIZE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint OrgApacheLuceneStoreMMapDirectory_DEFAULT_MAX_CHUNK_SIZE;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(OrgApacheLuceneStoreMMapDirectory, DEFAULT_MAX_CHUNK_SIZE, jint)

/*!
 @brief <code>true</code>, if this platform supports unmapping mmapped files.
 */
inline jboolean OrgApacheLuceneStoreMMapDirectory_get_UNMAP_SUPPORTED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jboolean OrgApacheLuceneStoreMMapDirectory_UNMAP_SUPPORTED;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(OrgApacheLuceneStoreMMapDirectory, UNMAP_SUPPORTED, jboolean)

FOUNDATION_EXPORT void OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_(OrgApacheLuceneStoreMMapDirectory *self, OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory);

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_(OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_(OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory);

FOUNDATION_EXPORT void OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_(OrgApacheLuceneStoreMMapDirectory *self, OrgLukhnosPortmobileFilePath *path);

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_(OrgLukhnosPortmobileFilePath *path) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_(OrgLukhnosPortmobileFilePath *path);

FOUNDATION_EXPORT void OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withInt_(OrgApacheLuceneStoreMMapDirectory *self, OrgLukhnosPortmobileFilePath *path, jint maxChunkSize);

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withInt_(OrgLukhnosPortmobileFilePath *path, jint maxChunkSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withInt_(OrgLukhnosPortmobileFilePath *path, jint maxChunkSize);

FOUNDATION_EXPORT void OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_withInt_(OrgApacheLuceneStoreMMapDirectory *self, OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory, jint maxChunkSize);

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *new_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_withInt_(OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory, jint maxChunkSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneStoreMMapDirectory *create_OrgApacheLuceneStoreMMapDirectory_initWithOrgLukhnosPortmobileFilePath_withOrgApacheLuceneStoreLockFactory_withInt_(OrgLukhnosPortmobileFilePath *path, OrgApacheLuceneStoreLockFactory *lockFactory, jint maxChunkSize);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneStoreMMapDirectory)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneStoreMMapDirectory")
