//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler")
#ifdef RESTRICT_OrgApacheLuceneIndexConcurrentMergeScheduler
#define INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler 0
#else
#define INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler 1
#endif
#undef RESTRICT_OrgApacheLuceneIndexConcurrentMergeScheduler

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheLuceneIndexConcurrentMergeScheduler_) && (INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler || defined(INCLUDE_OrgApacheLuceneIndexConcurrentMergeScheduler))
#define OrgApacheLuceneIndexConcurrentMergeScheduler_

#define RESTRICT_OrgApacheLuceneIndexMergeScheduler 1
#define INCLUDE_OrgApacheLuceneIndexMergeScheduler 1
#include "org/apache/lucene/index/MergeScheduler.h"

@class JavaLangThrowable;
@class OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread;
@class OrgApacheLuceneIndexIndexWriter;
@class OrgApacheLuceneIndexMergePolicy_OneMerge;
@class OrgApacheLuceneIndexMergeTrigger;
@class OrgApacheLuceneStoreDirectory;
@protocol JavaUtilList;

/*!
 @brief A <code>MergeScheduler</code> that runs each merge using a
   separate thread.
 <p>Specify the max number of threads that may run at
   once, and the maximum number of simultaneous merges
   with <code>setMaxMergesAndThreads</code>.</p>
   <p>If the number of merges exceeds the max number of threads 
   then the largest merges are paused until one of the smaller
   merges completes.</p>
   <p>If more than <code>getMaxMergeCount</code> merges are
   requested then this class will forcefully throttle the
   incoming threads by pausing until one more more merges
   complete.</p>
   <p>This class attempts to detect whether the index is
   on rotational storage (traditional hard drive) or not
   (e.g. solid-state disk) and changes the default max merge
   and thread count accordingly.  This detection is currently
   Linux-only, and relies on the OS to put the right value
   into /sys/block/&lt;dev&gt;/block/rotational.  For all
   other operating systems it currently assumes a rotational
   disk for backwards compatibility.  To enable default
   settings for spinning or solid state disks for such
   operating systems, use <code>setDefaultMaxMergesAndThreads(boolean)</code>.
 */
@interface OrgApacheLuceneIndexConcurrentMergeScheduler : OrgApacheLuceneIndexMergeScheduler {
 @public
  /*!
   @brief List of currently active <code>MergeThread</code>s.
   */
  id<JavaUtilList> mergeThreads_;
  /*!
   @brief How many <code>MergeThread</code>s have kicked off (this is use
   to name them).
   */
  jint mergeThreadCount_;
  /*!
   @brief Current IO writes throttle rate
   */
  jdouble targetMBPerSec_;
}
@property (readonly, class) jint AUTO_DETECT_MERGES_AND_THREADS NS_SWIFT_NAME(AUTO_DETECT_MERGES_AND_THREADS);
@property (readonly, copy, class) NSString *DEFAULT_CPU_CORE_COUNT_PROPERTY NS_SWIFT_NAME(DEFAULT_CPU_CORE_COUNT_PROPERTY);
@property (readonly, copy, class) NSString *DEFAULT_SPINS_PROPERTY NS_SWIFT_NAME(DEFAULT_SPINS_PROPERTY);

#pragma mark Public

/*!
 @brief Sole constructor, with all settings set to default
   values.
 */
- (instancetype __nonnull)init;

- (void)close;

/*!
 @brief Turn off auto IO throttling.
 - seealso: #enableAutoIOThrottle
 */
- (void)disableAutoIOThrottle;

/*!
 @brief Turn on dynamic IO throttling, to adaptively rate limit writes
   bytes/sec to the minimal rate necessary so merges do not fall behind.
 By default this is enabled.
 */
- (void)enableAutoIOThrottle;

/*!
 @brief Returns true if auto IO throttling is currently enabled.
 */
- (jboolean)getAutoIOThrottle;

/*!
 @brief Get the per-merge IO throttle rate for forced merges.
 */
- (jdouble)getForceMergeMBPerSec;

/*!
 @brief Returns the currently set per-merge IO writes rate limit, if <code>enableAutoIOThrottle</code>
   was called, else <code>Double.POSITIVE_INFINITY</code>.
 */
- (jdouble)getIORateLimitMBPerSec;

/*!
 @brief See <code>setMaxMergesAndThreads</code>.
 */
- (jint)getMaxMergeCount;

/*!
 @brief Returns <code>maxThreadCount</code>.
 - seealso: #setMaxMergesAndThreads(int, int)
 */
- (jint)getMaxThreadCount;

- (void)mergeWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
            withOrgApacheLuceneIndexMergeTrigger:(OrgApacheLuceneIndexMergeTrigger *)trigger
                                     withBoolean:(jboolean)newMergesFound;

/*!
 @brief Returns the number of merge threads that are alive, ignoring the calling thread
  if it is a merge thread.Note that this number is &le; <code>mergeThreads</code> size.
 */
- (jint)mergeThreadCount;

/*!
 @brief Sets max merges and threads to proper defaults for rotational
   or non-rotational storage.
 @param spins true to set defaults best for traditional rotatational storage (spinning disks),          else false (e.g. for solid-state disks)
 */
- (void)setDefaultMaxMergesAndThreadsWithBoolean:(jboolean)spins;

/*!
 @brief Set the per-merge IO throttle rate for forced merges (default: <code>Double.POSITIVE_INFINITY</code>).
 */
- (void)setForceMergeMBPerSecWithDouble:(jdouble)v;

/*!
 @brief Expert: directly set the maximum number of merge threads and
  simultaneous merges allowed.
 @param maxMergeCount the max # simultaneous merges that are allowed.        If a merge is necessary yet we already have this many
         threads running, the incoming thread (that is calling
         add/updateDocument) will block until a merge thread
         has completed.  Note that we will only run the
         smallest 
  <code> maxThreadCount </code>  merges at a time.
 @param maxThreadCount the max # simultaneous merge threads that should        be running at once.  This must be 
  &lt; =  <code> maxMergeCount </code>
 */
- (void)setMaxMergesAndThreadsWithInt:(jint)maxMergeCount
                              withInt:(jint)maxThreadCount;

/*!
 @brief Wait for any running merge threads to finish.This call is not interruptible as used by <code>close()</code>.
 */
- (void)sync;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Does the actual merge, by calling <code>IndexWriter.merge</code>
 */
- (void)doMergeWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
      withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

/*!
 @brief Called from <code>maybeStall</code> to pause the calling thread for a bit.
 */
- (void)doStall;

/*!
 @brief Create and return a new MergeThread
 */
- (OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *)getMergeThreadWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
                                                                   withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

/*!
 @brief Called when an exception is hit in a background merge
   thread
 */
- (void)handleMergeExceptionWithOrgApacheLuceneStoreDirectory:(OrgApacheLuceneStoreDirectory *)dir
                                        withJavaLangThrowable:(JavaLangThrowable *)exc;

/*!
 @brief This is invoked by <code>merge</code> to possibly stall the incoming
   thread when there are too many merges running or pending.The 
   default behavior is to force this thread, which is producing too
   many segments for merging to keep up, to wait until merges catch
   up.
 Applications that can take other less drastic measures, such
   as limiting how many threads are allowed to index, can do nothing
   here and throttle elsewhere.
   If this method wants to stall but the calling thread is a merge
   thread, it should return false to tell caller not to kick off
   any new merges.
 */
- (jboolean)maybeStallWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer;

/*!
 @brief Subclass can override to tweak targetMBPerSec.
 */
- (void)targetMBPerSecChanged;

/*!
 @brief Called whenever the running merges have changed, to set merge IO limits.
 This method sorts the merge threads by their merge size in
  descending order and then pauses/unpauses threads from first to last --
  that way, smaller merges are guaranteed to run before larger ones.
 */
- (void)updateMergeThreads;

#pragma mark Package-Private

/*!
 @brief Used for testing
 */
- (void)clearSuppressExceptions;

/*!
 @brief Removes the calling thread from the active merge threads.
 */
- (void)removeMergeThread;

/*!
 @brief Used for testing
 */
- (void)setSuppressExceptions;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneIndexConcurrentMergeScheduler)

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler, mergeThreads_, id<JavaUtilList>)

/*!
 @brief Dynamic default for <code>maxThreadCount</code> and <code>maxMergeCount</code>,
   used to detect whether the index is backed by an SSD or rotational disk and
   set <code>maxThreadCount</code> accordingly.If it's an SSD,
   <code>maxThreadCount</code> is set to <code>max(1, min(4, cpuCoreCount/2))</code>,
   otherwise 1.
 Note that detection only currently works on
   Linux; other platforms will assume the index is not on an SSD.
 */
inline jint OrgApacheLuceneIndexConcurrentMergeScheduler_get_AUTO_DETECT_MERGES_AND_THREADS(void);
#define OrgApacheLuceneIndexConcurrentMergeScheduler_AUTO_DETECT_MERGES_AND_THREADS -1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneIndexConcurrentMergeScheduler, AUTO_DETECT_MERGES_AND_THREADS, jint)

/*!
 @brief Used for testing.
 */
inline NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_get_DEFAULT_CPU_CORE_COUNT_PROPERTY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_DEFAULT_CPU_CORE_COUNT_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneIndexConcurrentMergeScheduler, DEFAULT_CPU_CORE_COUNT_PROPERTY, NSString *)

/*!
 @brief Used for testing.
 */
inline NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_get_DEFAULT_SPINS_PROPERTY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_DEFAULT_SPINS_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneIndexConcurrentMergeScheduler, DEFAULT_SPINS_PROPERTY, NSString *)

FOUNDATION_EXPORT void OrgApacheLuceneIndexConcurrentMergeScheduler_init(OrgApacheLuceneIndexConcurrentMergeScheduler *self);

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler *new_OrgApacheLuceneIndexConcurrentMergeScheduler_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler *create_OrgApacheLuceneIndexConcurrentMergeScheduler_init(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneIndexConcurrentMergeScheduler)

#endif

#if !defined (OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_) && (INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler || defined(INCLUDE_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread))
#define OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_

#define RESTRICT_JavaLangThread 1
#define INCLUDE_JavaLangThread 1
#include "java/lang/Thread.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class JavaLangThreadGroup;
@class OrgApacheLuceneIndexConcurrentMergeScheduler;
@class OrgApacheLuceneIndexIndexWriter;
@class OrgApacheLuceneIndexMergePolicy_OneMerge;
@protocol JavaLangRunnable;

/*!
 @brief Runs a merge thread to execute a single merge, then exits.
 */
@interface OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread : JavaLangThread < JavaLangComparable > {
 @public
  OrgApacheLuceneIndexIndexWriter *writer_;
  OrgApacheLuceneIndexMergePolicy_OneMerge *merge_;
}

#pragma mark Public

/*!
 @brief Sole constructor.
 */
- (instancetype __nonnull)initWithOrgApacheLuceneIndexConcurrentMergeScheduler:(OrgApacheLuceneIndexConcurrentMergeScheduler *)outer$
                                           withOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
                                  withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

- (jint)compareToWithId:(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *)other;

- (void)run;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)arg0
                                      withNSString:(NSString *)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)arg0
                                 withJavaLangRunnable:(id<JavaLangRunnable>)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)arg0
                                 withJavaLangRunnable:(id<JavaLangRunnable>)arg1
                                         withNSString:(NSString *)arg2 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)arg0
                                 withJavaLangRunnable:(id<JavaLangRunnable>)arg1
                                         withNSString:(NSString *)arg2
                                             withLong:(jlong)arg3 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)arg0
                                         withNSString:(NSString *)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithNSString:(NSString *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread)

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread, writer_, OrgApacheLuceneIndexIndexWriter *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread, merge_, OrgApacheLuceneIndexMergePolicy_OneMerge *)

FOUNDATION_EXPORT void OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *self, OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge);

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *new_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *create_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler")
