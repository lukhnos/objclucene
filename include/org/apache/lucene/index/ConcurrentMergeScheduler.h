//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler")
#ifdef RESTRICT_OrgApacheLuceneIndexConcurrentMergeScheduler
#define INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler 0
#else
#define INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler 1
#endif
#undef RESTRICT_OrgApacheLuceneIndexConcurrentMergeScheduler

#if !defined (OrgApacheLuceneIndexConcurrentMergeScheduler_) && (INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler || defined(INCLUDE_OrgApacheLuceneIndexConcurrentMergeScheduler))
#define OrgApacheLuceneIndexConcurrentMergeScheduler_

#define RESTRICT_OrgApacheLuceneIndexMergeScheduler 1
#define INCLUDE_OrgApacheLuceneIndexMergeScheduler 1
#include "org/apache/lucene/index/MergeScheduler.h"

@class OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread;
@class OrgApacheLuceneIndexIndexWriter;
@class OrgApacheLuceneIndexMergePolicy_OneMerge;
@class OrgApacheLuceneIndexMergeTrigger;
@class OrgApacheLuceneStoreDirectory;
@protocol JavaUtilList;

/*!
 @brief A <code>MergeScheduler</code> that runs each merge using a
 separate thread.
 <p>Specify the max number of threads that may run at
 once, and the maximum number of simultaneous merges
 with <code>setMaxMergesAndThreads</code>.</p>
 <p>If the number of merges exceeds the max number of threads 
 then the largest merges are paused until one of the smaller
 merges completes.</p>
 <p>If more than <code>getMaxMergeCount</code> merges are
 requested then this class will forcefully throttle the
 incoming threads by pausing until one more more merges
 complete.</p>
 <p>This class attempts to detect whether the index is
 on rotational storage (traditional hard drive) or not
 (e.g. solid-state disk) and changes the default max merge
 and thread count accordingly.  This detection is currently
 Linux-only, and relies on the OS to put the right value
 into /sys/block/&lt;dev&gt;/block/rotational.  For all
 other operating systems it currently assumes a rotational
 disk for backwards compatibility.  To enable default
 settings for spinning or solid state disks for such
 operating systems, use <code>setDefaultMaxMergesAndThreads(boolean)</code>.
 */
@interface OrgApacheLuceneIndexConcurrentMergeScheduler : OrgApacheLuceneIndexMergeScheduler {
 @public
  /*!
   @brief List of currently active <code>MergeThread</code>s.
   */
  id<JavaUtilList> mergeThreads_;
  /*!
   @brief How many <code>MergeThread</code>s have kicked off (this is use
 to name them).
   */
  jint mergeThreadCount_;
  /*!
   @brief Current IO writes throttle rate
   */
  jdouble targetMBPerSec_;
}

+ (jint)AUTO_DETECT_MERGES_AND_THREADS;

+ (NSString *)DEFAULT_CPU_CORE_COUNT_PROPERTY;

+ (NSString *)DEFAULT_SPINS_PROPERTY;

#pragma mark Public

/*!
 @brief Sole constructor, with all settings set to default
 values.
 */
- (instancetype)init;

- (void)close;

/*!
 @brief Turn off auto IO throttling.
 - seealso: #enableAutoIOThrottle
 */
- (void)disableAutoIOThrottle;

/*!
 @brief Turn on dynamic IO throttling, to adaptively rate limit writes
 bytes/sec to the minimal rate necessary so merges do not fall behind.
 By default this is enabled. 
 */
- (void)enableAutoIOThrottle;

/*!
 @brief Returns true if auto IO throttling is currently enabled.
 */
- (jboolean)getAutoIOThrottle;

/*!
 @brief Get the per-merge IO throttle rate for forced merges.
 */
- (jdouble)getForceMergeMBPerSec;

/*!
 @brief Returns the currently set per-merge IO writes rate limit, if <code>enableAutoIOThrottle</code>
 was called, else <code>Double.POSITIVE_INFINITY</code>.
 */
- (jdouble)getIORateLimitMBPerSec;

/*!
 @brief See <code>setMaxMergesAndThreads</code>.
 */
- (jint)getMaxMergeCount;

/*!
 @brief Returns <code>maxThreadCount</code>.
 - seealso: #setMaxMergesAndThreads(int,int)
 */
- (jint)getMaxThreadCount;

- (void)mergeWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
            withOrgApacheLuceneIndexMergeTrigger:(OrgApacheLuceneIndexMergeTrigger *)trigger
                                     withBoolean:(jboolean)newMergesFound;

/*!
 @brief Returns the number of merge threads that are alive, ignoring the calling thread
 if it is a merge thread.
 Note that this number is &le; <code>mergeThreads</code> size.
 */
- (jint)mergeThreadCount;

/*!
 @brief Sets max merges and threads to proper defaults for rotational
 or non-rotational storage.
 @param spins true to set defaults best for traditional rotatational storage (spinning disks), 
 else false (e.g. for solid-state disks)
 */
- (void)setDefaultMaxMergesAndThreadsWithBoolean:(jboolean)spins;

/*!
 @brief Set the per-merge IO throttle rate for forced merges (default: <code>Double.POSITIVE_INFINITY</code>).
 */
- (void)setForceMergeMBPerSecWithDouble:(jdouble)v;

/*!
 @brief Expert: directly set the maximum number of merge threads and
 simultaneous merges allowed.
 @param maxMergeCount the max # simultaneous merges that are allowed.
 If a merge is necessary yet we already have this many
 threads running, the incoming thread (that is calling
 add/updateDocument) will block until a merge thread
 has completed.  Note that we will only run the
 smallest <code>maxThreadCount</code> merges at a time.
 @param maxThreadCount the max # simultaneous merge threads that should
 be running at once.  This must be &lt;= <code>maxMergeCount</code>
 */
- (void)setMaxMergesAndThreadsWithInt:(jint)maxMergeCount
                              withInt:(jint)maxThreadCount;

/*!
 @brief Wait for any running merge threads to finish.
 This call is not interruptible as used by <code>close()</code>. 
 */
- (void)sync;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Does the actual merge, by calling <code>IndexWriter.merge</code>
 */
- (void)doMergeWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
      withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

/*!
 @brief Called from <code>maybeStall</code> to pause the calling thread for a bit.
 */
- (void)doStall;

/*!
 @brief Create and return a new MergeThread
 */
- (OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *)getMergeThreadWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
                                                                   withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

/*!
 @brief Called when an exception is hit in a background merge
 thread
 */
- (void)handleMergeExceptionWithOrgApacheLuceneStoreDirectory:(OrgApacheLuceneStoreDirectory *)dir
                                              withNSException:(NSException *)exc;

/*!
 @brief This is invoked by <code>merge</code> to possibly stall the incoming
 thread when there are too many merges running or pending.
 The 
 default behavior is to force this thread, which is producing too
 many segments for merging to keep up, to wait until merges catch
 up. Applications that can take other less drastic measures, such
 as limiting how many threads are allowed to index, can do nothing
 here and throttle elsewhere.
 If this method wants to stall but the calling thread is a merge
 thread, it should return false to tell caller not to kick off
 any new merges. 
 */
- (jboolean)maybeStallWithOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer;

/*!
 @brief Subclass can override to tweak targetMBPerSec.
 */
- (void)targetMBPerSecChanged;

/*!
 @brief Called whenever the running merges have changed, to set merge IO limits.
 This method sorts the merge threads by their merge size in
 descending order and then pauses/unpauses threads from first to last --
 that way, smaller merges are guaranteed to run before larger ones.
 */
- (void)updateMergeThreads;

#pragma mark Package-Private

/*!
 @brief Used for testing
 */
- (void)clearSuppressExceptions;

/*!
 @brief Removes the calling thread from the active merge threads.
 */
- (void)removeMergeThread;

/*!
 @brief Used for testing
 */
- (void)setSuppressExceptions;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneIndexConcurrentMergeScheduler)

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler, mergeThreads_, id<JavaUtilList>)

/*!
 @brief Dynamic default for <code>maxThreadCount</code> and <code>maxMergeCount</code>,
 used to detect whether the index is backed by an SSD or rotational disk and
 set <code>maxThreadCount</code> accordingly.
 If it's an SSD,
 <code>maxThreadCount</code> is set to <code>max(1, min(4, cpuCoreCount/2))</code>,
 otherwise 1.  Note that detection only currently works on
 Linux; other platforms will assume the index is not on an SSD. 
 */
inline jint OrgApacheLuceneIndexConcurrentMergeScheduler_get_AUTO_DETECT_MERGES_AND_THREADS();
#define OrgApacheLuceneIndexConcurrentMergeScheduler_AUTO_DETECT_MERGES_AND_THREADS -1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheLuceneIndexConcurrentMergeScheduler, AUTO_DETECT_MERGES_AND_THREADS, jint)

/*!
 @brief Used for testing.
  
 */
inline NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_get_DEFAULT_CPU_CORE_COUNT_PROPERTY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_DEFAULT_CPU_CORE_COUNT_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneIndexConcurrentMergeScheduler, DEFAULT_CPU_CORE_COUNT_PROPERTY, NSString *)

/*!
 @brief Used for testing.
  
 */
inline NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_get_DEFAULT_SPINS_PROPERTY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *OrgApacheLuceneIndexConcurrentMergeScheduler_DEFAULT_SPINS_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgApacheLuceneIndexConcurrentMergeScheduler, DEFAULT_SPINS_PROPERTY, NSString *)

FOUNDATION_EXPORT void OrgApacheLuceneIndexConcurrentMergeScheduler_init(OrgApacheLuceneIndexConcurrentMergeScheduler *self);

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler *new_OrgApacheLuceneIndexConcurrentMergeScheduler_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler *create_OrgApacheLuceneIndexConcurrentMergeScheduler_init();

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneIndexConcurrentMergeScheduler)

#endif

#if !defined (OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_) && (INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler || defined(INCLUDE_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread))
#define OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_

#define RESTRICT_JavaLangThread 1
#define INCLUDE_JavaLangThread 1
#include "java/lang/Thread.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class OrgApacheLuceneIndexConcurrentMergeScheduler;
@class OrgApacheLuceneIndexIndexWriter;
@class OrgApacheLuceneIndexMergePolicy_OneMerge;

/*!
 @brief Runs a merge thread to execute a single merge, then exits.
 */
@interface OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread : JavaLangThread < JavaLangComparable > {
 @public
  OrgApacheLuceneIndexIndexWriter *writer_;
  OrgApacheLuceneIndexMergePolicy_OneMerge *merge_;
}

#pragma mark Public

/*!
 @brief Sole constructor.
 */
- (instancetype)initWithOrgApacheLuceneIndexConcurrentMergeScheduler:(OrgApacheLuceneIndexConcurrentMergeScheduler *)outer$
                                 withOrgApacheLuceneIndexIndexWriter:(OrgApacheLuceneIndexIndexWriter *)writer
                        withOrgApacheLuceneIndexMergePolicy_OneMerge:(OrgApacheLuceneIndexMergePolicy_OneMerge *)merge;

- (jint)compareToWithId:(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *)other;

- (void)run;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread)

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread, writer_, OrgApacheLuceneIndexIndexWriter *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread, merge_, OrgApacheLuceneIndexMergePolicy_OneMerge *)

FOUNDATION_EXPORT void OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *self, OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge);

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *new_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread *create_OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread_initWithOrgApacheLuceneIndexConcurrentMergeScheduler_withOrgApacheLuceneIndexIndexWriter_withOrgApacheLuceneIndexMergePolicy_OneMerge_(OrgApacheLuceneIndexConcurrentMergeScheduler *outer$, OrgApacheLuceneIndexIndexWriter *writer, OrgApacheLuceneIndexMergePolicy_OneMerge *merge);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneIndexConcurrentMergeScheduler_MergeThread)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneIndexConcurrentMergeScheduler")
