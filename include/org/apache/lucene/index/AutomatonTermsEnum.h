//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheLuceneIndexAutomatonTermsEnum")
#ifdef RESTRICT_OrgApacheLuceneIndexAutomatonTermsEnum
#define INCLUDE_ALL_OrgApacheLuceneIndexAutomatonTermsEnum 0
#else
#define INCLUDE_ALL_OrgApacheLuceneIndexAutomatonTermsEnum 1
#endif
#undef RESTRICT_OrgApacheLuceneIndexAutomatonTermsEnum

#if !defined (OrgApacheLuceneIndexAutomatonTermsEnum_) && (INCLUDE_ALL_OrgApacheLuceneIndexAutomatonTermsEnum || defined(INCLUDE_OrgApacheLuceneIndexAutomatonTermsEnum))
#define OrgApacheLuceneIndexAutomatonTermsEnum_

#define RESTRICT_OrgApacheLuceneIndexFilteredTermsEnum 1
#define INCLUDE_OrgApacheLuceneIndexFilteredTermsEnum 1
#include "org/apache/lucene/index/FilteredTermsEnum.h"

@class OrgApacheLuceneIndexFilteredTermsEnum_AcceptStatus;
@class OrgApacheLuceneIndexTermsEnum;
@class OrgApacheLuceneUtilAutomatonCompiledAutomaton;
@class OrgApacheLuceneUtilBytesRef;

/*!
 @brief A FilteredTermsEnum that enumerates terms based upon what is accepted by a
 DFA.
 <p>
 The algorithm is such:
 <ol>
 <li>As long as matches are successful, keep reading sequentially.
 <li>When a match fails, skip to the next string in lexicographic order that
 does not enter a reject state.
 </ol>
 <p>
 The algorithm does not attempt to actually skip to the next string that is
 completely accepted. This is not possible when the language accepted by the
 FSM is not finite (i.e. * operator).
 </p>
 */
@interface OrgApacheLuceneIndexAutomatonTermsEnum : OrgApacheLuceneIndexFilteredTermsEnum

#pragma mark Public

/*!
 @brief Construct an enumerator based upon an automaton, enumerating the specified
 field, working on a supplied TermsEnum
  
 @param compiled CompiledAutomaton
 */
- (instancetype)initWithOrgApacheLuceneIndexTermsEnum:(OrgApacheLuceneIndexTermsEnum *)tenum
    withOrgApacheLuceneUtilAutomatonCompiledAutomaton:(OrgApacheLuceneUtilAutomatonCompiledAutomaton *)compiled;

#pragma mark Protected

/*!
 @brief Returns true if the term matches the automaton.
 Also stashes away the term
 to assist with smart enumeration.
 */
- (OrgApacheLuceneIndexFilteredTermsEnum_AcceptStatus *)acceptWithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)term;

- (OrgApacheLuceneUtilBytesRef *)nextSeekTermWithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)term;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheLuceneIndexAutomatonTermsEnum)

FOUNDATION_EXPORT void OrgApacheLuceneIndexAutomatonTermsEnum_initWithOrgApacheLuceneIndexTermsEnum_withOrgApacheLuceneUtilAutomatonCompiledAutomaton_(OrgApacheLuceneIndexAutomatonTermsEnum *self, OrgApacheLuceneIndexTermsEnum *tenum, OrgApacheLuceneUtilAutomatonCompiledAutomaton *compiled);

FOUNDATION_EXPORT OrgApacheLuceneIndexAutomatonTermsEnum *new_OrgApacheLuceneIndexAutomatonTermsEnum_initWithOrgApacheLuceneIndexTermsEnum_withOrgApacheLuceneUtilAutomatonCompiledAutomaton_(OrgApacheLuceneIndexTermsEnum *tenum, OrgApacheLuceneUtilAutomatonCompiledAutomaton *compiled) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheLuceneIndexAutomatonTermsEnum *create_OrgApacheLuceneIndexAutomatonTermsEnum_initWithOrgApacheLuceneIndexTermsEnum_withOrgApacheLuceneUtilAutomatonCompiledAutomaton_(OrgApacheLuceneIndexTermsEnum *tenum, OrgApacheLuceneUtilAutomatonCompiledAutomaton *compiled);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheLuceneIndexAutomatonTermsEnum)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgApacheLuceneIndexAutomatonTermsEnum")
