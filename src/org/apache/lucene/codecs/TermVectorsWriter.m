//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/codecs/TermVectorsWriter.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/util/Iterator.h"
#include "org/apache/lucene/codecs/TermVectorsReader.h"
#include "org/apache/lucene/codecs/TermVectorsWriter.h"
#include "org/apache/lucene/index/FieldInfo.h"
#include "org/apache/lucene/index/FieldInfos.h"
#include "org/apache/lucene/index/Fields.h"
#include "org/apache/lucene/index/MergeState.h"
#include "org/apache/lucene/index/PostingsEnum.h"
#include "org/apache/lucene/index/Terms.h"
#include "org/apache/lucene/index/TermsEnum.h"
#include "org/apache/lucene/search/DocIdSetIterator.h"
#include "org/apache/lucene/store/DataInput.h"
#include "org/apache/lucene/util/Bits.h"
#include "org/apache/lucene/util/BytesRef.h"
#include "org/apache/lucene/util/BytesRefBuilder.h"

__attribute__((unused)) static void OrgApacheLuceneCodecsTermVectorsWriter_addAllDocVectorsWithOrgApacheLuceneIndexFields_withOrgApacheLuceneIndexMergeState_(OrgApacheLuceneCodecsTermVectorsWriter *self, OrgApacheLuceneIndexFields *vectors, OrgApacheLuceneIndexMergeState *mergeState);

@implementation OrgApacheLuceneCodecsTermVectorsWriter

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgApacheLuceneCodecsTermVectorsWriter_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)startDocumentWithInt:(jint)numVectorFields {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)finishDocument {
}

- (void)startFieldWithOrgApacheLuceneIndexFieldInfo:(OrgApacheLuceneIndexFieldInfo *)info
                                            withInt:(jint)numTerms
                                        withBoolean:(jboolean)positions
                                        withBoolean:(jboolean)offsets
                                        withBoolean:(jboolean)payloads {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)finishField {
}

- (void)startTermWithOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)term
                                         withInt:(jint)freq {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)finishTerm {
}

- (void)addPositionWithInt:(jint)position
                   withInt:(jint)startOffset
                   withInt:(jint)endOffset
withOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)payload {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)finishWithOrgApacheLuceneIndexFieldInfos:(OrgApacheLuceneIndexFieldInfos *)fis
                                         withInt:(jint)numDocs {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)addProxWithInt:(jint)numProx
withOrgApacheLuceneStoreDataInput:(OrgApacheLuceneStoreDataInput *)positions
withOrgApacheLuceneStoreDataInput:(OrgApacheLuceneStoreDataInput *)offsets {
  jint position = 0;
  jint lastOffset = 0;
  OrgApacheLuceneUtilBytesRefBuilder *payload = nil;
  for (jint i = 0; i < numProx; i++) {
    jint startOffset;
    jint endOffset;
    OrgApacheLuceneUtilBytesRef *thisPayload;
    if (positions == nil) {
      position = -1;
      thisPayload = nil;
    }
    else {
      jint code = [positions readVInt];
      position += JreURShift32(code, 1);
      if ((code & 1) != 0) {
        jint payloadLength = [positions readVInt];
        if (payload == nil) {
          payload = create_OrgApacheLuceneUtilBytesRefBuilder_init();
        }
        [payload growWithInt:payloadLength];
        [positions readBytesWithByteArray:[payload bytes] withInt:0 withInt:payloadLength];
        [payload setLengthWithInt:payloadLength];
        thisPayload = [payload get];
      }
      else {
        thisPayload = nil;
      }
    }
    if (offsets == nil) {
      startOffset = endOffset = -1;
    }
    else {
      startOffset = lastOffset + [offsets readVInt];
      endOffset = startOffset + [offsets readVInt];
      lastOffset = endOffset;
    }
    [self addPositionWithInt:position withInt:startOffset withInt:endOffset withOrgApacheLuceneUtilBytesRef:thisPayload];
  }
}

- (jint)mergeWithOrgApacheLuceneIndexMergeState:(OrgApacheLuceneIndexMergeState *)mergeState {
  jint docCount = 0;
  jint numReaders = ((IOSIntArray *) nil_chk(((OrgApacheLuceneIndexMergeState *) nil_chk(mergeState))->maxDocs_))->size_;
  for (jint i = 0; i < numReaders; i++) {
    jint maxDoc = IOSIntArray_Get(mergeState->maxDocs_, i);
    id<OrgApacheLuceneUtilBits> liveDocs = IOSObjectArray_Get(nil_chk(mergeState->liveDocs_), i);
    OrgApacheLuceneCodecsTermVectorsReader *termVectorsReader = IOSObjectArray_Get(nil_chk(mergeState->termVectorsReaders_), i);
    if (termVectorsReader != nil) {
      [termVectorsReader checkIntegrity];
    }
    for (jint docID = 0; docID < maxDoc; docID++) {
      if (liveDocs != nil && ![liveDocs getWithInt:docID]) {
        continue;
      }
      OrgApacheLuceneIndexFields *vectors;
      if (termVectorsReader == nil) {
        vectors = nil;
      }
      else {
        vectors = [termVectorsReader getWithInt:docID];
      }
      OrgApacheLuceneCodecsTermVectorsWriter_addAllDocVectorsWithOrgApacheLuceneIndexFields_withOrgApacheLuceneIndexMergeState_(self, vectors, mergeState);
      docCount++;
    }
  }
  [self finishWithOrgApacheLuceneIndexFieldInfos:mergeState->mergeFieldInfos_ withInt:docCount];
  return docCount;
}

- (void)addAllDocVectorsWithOrgApacheLuceneIndexFields:(OrgApacheLuceneIndexFields *)vectors
                    withOrgApacheLuceneIndexMergeState:(OrgApacheLuceneIndexMergeState *)mergeState {
  OrgApacheLuceneCodecsTermVectorsWriter_addAllDocVectorsWithOrgApacheLuceneIndexFields_withOrgApacheLuceneIndexMergeState_(self, vectors, mergeState);
}

- (void)close {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "TermVectorsWriter", NULL, 0x4, NULL, NULL },
    { "startDocumentWithInt:", "startDocument", "V", 0x401, "Ljava.io.IOException;", NULL },
    { "finishDocument", NULL, "V", 0x1, "Ljava.io.IOException;", NULL },
    { "startFieldWithOrgApacheLuceneIndexFieldInfo:withInt:withBoolean:withBoolean:withBoolean:", "startField", "V", 0x401, "Ljava.io.IOException;", NULL },
    { "finishField", NULL, "V", 0x1, "Ljava.io.IOException;", NULL },
    { "startTermWithOrgApacheLuceneUtilBytesRef:withInt:", "startTerm", "V", 0x401, "Ljava.io.IOException;", NULL },
    { "finishTerm", NULL, "V", 0x1, "Ljava.io.IOException;", NULL },
    { "addPositionWithInt:withInt:withInt:withOrgApacheLuceneUtilBytesRef:", "addPosition", "V", 0x401, "Ljava.io.IOException;", NULL },
    { "finishWithOrgApacheLuceneIndexFieldInfos:withInt:", "finish", "V", 0x401, "Ljava.io.IOException;", NULL },
    { "addProxWithInt:withOrgApacheLuceneStoreDataInput:withOrgApacheLuceneStoreDataInput:", "addProx", "V", 0x1, "Ljava.io.IOException;", NULL },
    { "mergeWithOrgApacheLuceneIndexMergeState:", "merge", "I", 0x1, "Ljava.io.IOException;", NULL },
    { "addAllDocVectorsWithOrgApacheLuceneIndexFields:withOrgApacheLuceneIndexMergeState:", "addAllDocVectors", "V", 0x14, "Ljava.io.IOException;", NULL },
    { "close", NULL, "V", 0x401, "Ljava.io.IOException;", NULL },
  };
  static const J2ObjcClassInfo _OrgApacheLuceneCodecsTermVectorsWriter = { 2, "TermVectorsWriter", "org.apache.lucene.codecs", NULL, 0x401, 13, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheLuceneCodecsTermVectorsWriter;
}

@end

void OrgApacheLuceneCodecsTermVectorsWriter_init(OrgApacheLuceneCodecsTermVectorsWriter *self) {
  NSObject_init(self);
}

void OrgApacheLuceneCodecsTermVectorsWriter_addAllDocVectorsWithOrgApacheLuceneIndexFields_withOrgApacheLuceneIndexMergeState_(OrgApacheLuceneCodecsTermVectorsWriter *self, OrgApacheLuceneIndexFields *vectors, OrgApacheLuceneIndexMergeState *mergeState) {
  if (vectors == nil) {
    [self startDocumentWithInt:0];
    [self finishDocument];
    return;
  }
  jint numFields = [vectors size];
  if (numFields == -1) {
    numFields = 0;
    for (id<JavaUtilIterator> it = [vectors iterator]; [((id<JavaUtilIterator>) nil_chk(it)) hasNext]; ) {
      [it next];
      numFields++;
    }
  }
  [self startDocumentWithInt:numFields];
  NSString *lastFieldName = nil;
  OrgApacheLuceneIndexTermsEnum *termsEnum = nil;
  OrgApacheLuceneIndexPostingsEnum *docsAndPositionsEnum = nil;
  jint fieldCount = 0;
  for (NSString * __strong fieldName in vectors) {
    fieldCount++;
    OrgApacheLuceneIndexFieldInfo *fieldInfo = [((OrgApacheLuceneIndexFieldInfos *) nil_chk(((OrgApacheLuceneIndexMergeState *) nil_chk(mergeState))->mergeFieldInfos_)) fieldInfoWithNSString:fieldName];
    JreAssert((lastFieldName == nil || [((NSString *) nil_chk(fieldName)) compareToWithId:lastFieldName] > 0), (JreStrcat("$$$$", @"lastFieldName=", lastFieldName, @" fieldName=", fieldName)));
    lastFieldName = fieldName;
    OrgApacheLuceneIndexTerms *terms = [vectors termsWithNSString:fieldName];
    if (terms == nil) {
      continue;
    }
    jboolean hasPositions = [terms hasPositions];
    jboolean hasOffsets = [terms hasOffsets];
    jboolean hasPayloads = [terms hasPayloads];
    JreAssert((!hasPayloads || hasPositions), (@"org/apache/lucene/codecs/TermVectorsWriter.java:246 condition failed: assert !hasPayloads || hasPositions;"));
    jint numTerms = (jint) [terms size];
    if (numTerms == -1) {
      numTerms = 0;
      termsEnum = [terms iterator];
      while ([((OrgApacheLuceneIndexTermsEnum *) nil_chk(termsEnum)) next] != nil) {
        numTerms++;
      }
    }
    [self startFieldWithOrgApacheLuceneIndexFieldInfo:fieldInfo withInt:numTerms withBoolean:hasPositions withBoolean:hasOffsets withBoolean:hasPayloads];
    termsEnum = [terms iterator];
    jint termCount = 0;
    while ([((OrgApacheLuceneIndexTermsEnum *) nil_chk(termsEnum)) next] != nil) {
      termCount++;
      jint freq = (jint) [termsEnum totalTermFreq];
      [self startTermWithOrgApacheLuceneUtilBytesRef:[termsEnum term] withInt:freq];
      if (hasPositions || hasOffsets) {
        docsAndPositionsEnum = [termsEnum postingsWithOrgApacheLuceneIndexPostingsEnum:docsAndPositionsEnum withInt:OrgApacheLuceneIndexPostingsEnum_OFFSETS | OrgApacheLuceneIndexPostingsEnum_PAYLOADS];
        JreAssert((docsAndPositionsEnum != nil), (@"org/apache/lucene/codecs/TermVectorsWriter.java:271 condition failed: assert docsAndPositionsEnum != null;"));
        jint docID = [((OrgApacheLuceneIndexPostingsEnum *) nil_chk(docsAndPositionsEnum)) nextDoc];
        JreAssert((docID != OrgApacheLuceneSearchDocIdSetIterator_NO_MORE_DOCS), (@"org/apache/lucene/codecs/TermVectorsWriter.java:274 condition failed: assert docID != DocIdSetIterator.NO_MORE_DOCS;"));
        JreAssert(([docsAndPositionsEnum freq] == freq), (@"org/apache/lucene/codecs/TermVectorsWriter.java:275 condition failed: assert docsAndPositionsEnum.freq() == freq;"));
        for (jint posUpto = 0; posUpto < freq; posUpto++) {
          jint pos = [docsAndPositionsEnum nextPosition];
          jint startOffset = [docsAndPositionsEnum startOffset];
          jint endOffset = [docsAndPositionsEnum endOffset];
          OrgApacheLuceneUtilBytesRef *payload = [docsAndPositionsEnum getPayload];
          JreAssert((!hasPositions || pos >= 0), (@"org/apache/lucene/codecs/TermVectorsWriter.java:284 condition failed: assert !hasPositions || pos >= 0 ;"));
          [self addPositionWithInt:pos withInt:startOffset withInt:endOffset withOrgApacheLuceneUtilBytesRef:payload];
        }
      }
      [self finishTerm];
    }
    JreAssert((termCount == numTerms), (@"org/apache/lucene/codecs/TermVectorsWriter.java:290 condition failed: assert termCount == numTerms;"));
    [self finishField];
  }
  JreAssert((fieldCount == numFields), (@"org/apache/lucene/codecs/TermVectorsWriter.java:293 condition failed: assert fieldCount == numFields;"));
  [self finishDocument];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneCodecsTermVectorsWriter)
