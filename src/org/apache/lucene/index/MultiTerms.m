//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/index/MultiTerms.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "org/apache/lucene/index/MultiTerms.h"
#include "org/apache/lucene/index/MultiTermsEnum.h"
#include "org/apache/lucene/index/Terms.h"
#include "org/apache/lucene/index/TermsEnum.h"
#include "org/apache/lucene/util/BytesRef.h"
#include "org/apache/lucene/util/automaton/CompiledAutomaton.h"

@interface OrgApacheLuceneIndexMultiTerms () {
 @public
  IOSObjectArray *subs_;
  IOSObjectArray *subSlices_;
  jboolean hasFreqs_;
  jboolean hasOffsets_;
  jboolean hasPositions_;
  jboolean hasPayloads_;
}

@end

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexMultiTerms, subs_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexMultiTerms, subSlices_, IOSObjectArray *)

@implementation OrgApacheLuceneIndexMultiTerms

- (instancetype)initWithOrgApacheLuceneIndexTermsArray:(IOSObjectArray *)subs
              withOrgApacheLuceneIndexReaderSliceArray:(IOSObjectArray *)subSlices {
  OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(self, subs, subSlices);
  return self;
}

- (IOSObjectArray *)getSubTerms {
  return subs_;
}

- (IOSObjectArray *)getSubSlices {
  return subSlices_;
}

- (OrgApacheLuceneIndexTermsEnum *)intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:(OrgApacheLuceneUtilAutomatonCompiledAutomaton *)compiled
                                                              withOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)startTerm {
  id<JavaUtilList> termsEnums = create_JavaUtilArrayList_init();
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(subs_))->size_; i++) {
    OrgApacheLuceneIndexTermsEnum *termsEnum = [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs_, i))) intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:compiled withOrgApacheLuceneUtilBytesRef:startTerm];
    if (termsEnum != nil) {
      [termsEnums addWithId:create_OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex_initWithOrgApacheLuceneIndexTermsEnum_withInt_(termsEnum, i)];
    }
  }
  if ([termsEnums size] > 0) {
    return [create_OrgApacheLuceneIndexMultiTermsEnum_initWithOrgApacheLuceneIndexReaderSliceArray_(subSlices_) resetWithOrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndexArray:[termsEnums toArrayWithNSObjectArray:JreLoadStatic(OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex, EMPTY_ARRAY)]];
  }
  else {
    return JreLoadStatic(OrgApacheLuceneIndexTermsEnum, EMPTY);
  }
}

- (OrgApacheLuceneUtilBytesRef *)getMin {
  OrgApacheLuceneUtilBytesRef *minTerm = nil;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      OrgApacheLuceneUtilBytesRef *term = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getMin];
      if (minTerm == nil || [((OrgApacheLuceneUtilBytesRef *) nil_chk(term)) compareToWithId:minTerm] < 0) {
        minTerm = term;
      }
    }
  }
  return minTerm;
}

- (OrgApacheLuceneUtilBytesRef *)getMax {
  OrgApacheLuceneUtilBytesRef *maxTerm = nil;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      OrgApacheLuceneUtilBytesRef *term = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getMax];
      if (maxTerm == nil || [((OrgApacheLuceneUtilBytesRef *) nil_chk(term)) compareToWithId:maxTerm] > 0) {
        maxTerm = term;
      }
    }
  }
  return maxTerm;
}

- (OrgApacheLuceneIndexTermsEnum *)iterator {
  id<JavaUtilList> termsEnums = create_JavaUtilArrayList_init();
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(subs_))->size_; i++) {
    OrgApacheLuceneIndexTermsEnum *termsEnum = [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs_, i))) iterator];
    if (termsEnum != nil) {
      [termsEnums addWithId:create_OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex_initWithOrgApacheLuceneIndexTermsEnum_withInt_(termsEnum, i)];
    }
  }
  if ([termsEnums size] > 0) {
    return [create_OrgApacheLuceneIndexMultiTermsEnum_initWithOrgApacheLuceneIndexReaderSliceArray_(subSlices_) resetWithOrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndexArray:[termsEnums toArrayWithNSObjectArray:JreLoadStatic(OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex, EMPTY_ARRAY)]];
  }
  else {
    return JreLoadStatic(OrgApacheLuceneIndexTermsEnum, EMPTY);
  }
}

- (jlong)size {
  return -1;
}

- (jlong)getSumTotalTermFreq {
  jlong sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jlong v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getSumTotalTermFreq];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jlong)getSumDocFreq {
  jlong sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jlong v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getSumDocFreq];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jint)getDocCount {
  jint sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jint v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getDocCount];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jboolean)hasFreqs {
  return hasFreqs_;
}

- (jboolean)hasOffsets {
  return hasOffsets_;
}

- (jboolean)hasPositions {
  return hasPositions_;
}

- (jboolean)hasPayloads {
  return hasPayloads_;
}

- (void)dealloc {
  RELEASE_(subs_);
  RELEASE_(subSlices_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithOrgApacheLuceneIndexTermsArray:withOrgApacheLuceneIndexReaderSliceArray:", "MultiTerms", NULL, 0x1, "Ljava.io.IOException;", NULL },
    { "getSubTerms", NULL, "[Lorg.apache.lucene.index.Terms;", 0x1, NULL, NULL },
    { "getSubSlices", NULL, "[Lorg.apache.lucene.index.ReaderSlice;", 0x1, NULL, NULL },
    { "intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:withOrgApacheLuceneUtilBytesRef:", "intersect", "Lorg.apache.lucene.index.TermsEnum;", 0x1, "Ljava.io.IOException;", NULL },
    { "getMin", NULL, "Lorg.apache.lucene.util.BytesRef;", 0x1, "Ljava.io.IOException;", NULL },
    { "getMax", NULL, "Lorg.apache.lucene.util.BytesRef;", 0x1, "Ljava.io.IOException;", NULL },
    { "iterator", NULL, "Lorg.apache.lucene.index.TermsEnum;", 0x1, "Ljava.io.IOException;", NULL },
    { "size", NULL, "J", 0x1, NULL, NULL },
    { "getSumTotalTermFreq", NULL, "J", 0x1, "Ljava.io.IOException;", NULL },
    { "getSumDocFreq", NULL, "J", 0x1, "Ljava.io.IOException;", NULL },
    { "getDocCount", NULL, "I", 0x1, "Ljava.io.IOException;", NULL },
    { "hasFreqs", NULL, "Z", 0x1, NULL, NULL },
    { "hasOffsets", NULL, "Z", 0x1, NULL, NULL },
    { "hasPositions", NULL, "Z", 0x1, NULL, NULL },
    { "hasPayloads", NULL, "Z", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "subs_", NULL, 0x12, "[Lorg.apache.lucene.index.Terms;", NULL, NULL, .constantValue.asLong = 0 },
    { "subSlices_", NULL, 0x12, "[Lorg.apache.lucene.index.ReaderSlice;", NULL, NULL, .constantValue.asLong = 0 },
    { "hasFreqs_", NULL, 0x12, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "hasOffsets_", NULL, 0x12, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "hasPositions_", NULL, 0x12, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "hasPayloads_", NULL, 0x12, "Z", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _OrgApacheLuceneIndexMultiTerms = { 2, "MultiTerms", "org.apache.lucene.index", NULL, 0x11, 15, methods, 6, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheLuceneIndexMultiTerms;
}

@end

void OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(OrgApacheLuceneIndexMultiTerms *self, IOSObjectArray *subs, IOSObjectArray *subSlices) {
  OrgApacheLuceneIndexTerms_init(self);
  JreStrongAssign(&self->subs_, subs);
  JreStrongAssign(&self->subSlices_, subSlices);
  JreAssert((((IOSObjectArray *) nil_chk(subs))->size_ > 0), (@"inefficient: don't use MultiTerms over one sub"));
  jboolean _hasFreqs = true;
  jboolean _hasOffsets = true;
  jboolean _hasPositions = true;
  jboolean _hasPayloads = false;
  for (jint i = 0; i < subs->size_; i++) {
    _hasFreqs &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasFreqs];
    _hasOffsets &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasOffsets];
    _hasPositions &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasPositions];
    _hasPayloads |= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasPayloads];
  }
  self->hasFreqs_ = _hasFreqs;
  self->hasOffsets_ = _hasOffsets;
  self->hasPositions_ = _hasPositions;
  self->hasPayloads_ = (self->hasPositions_ && _hasPayloads);
}

OrgApacheLuceneIndexMultiTerms *new_OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(IOSObjectArray *subs, IOSObjectArray *subSlices) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneIndexMultiTerms, initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_, subs, subSlices)
}

OrgApacheLuceneIndexMultiTerms *create_OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(IOSObjectArray *subs, IOSObjectArray *subSlices) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneIndexMultiTerms, initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_, subs, subSlices)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneIndexMultiTerms)
