//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./core/src/java/org/apache/lucene/index/MultiTerms.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "org/apache/lucene/index/MultiTerms.h"
#include "org/apache/lucene/index/MultiTermsEnum.h"
#include "org/apache/lucene/index/Terms.h"
#include "org/apache/lucene/index/TermsEnum.h"
#include "org/apache/lucene/util/BytesRef.h"
#include "org/apache/lucene/util/automaton/CompiledAutomaton.h"

#if __has_feature(objc_arc)
#error "org/apache/lucene/index/MultiTerms must not be compiled with ARC (-fobjc-arc)"
#endif

@interface OrgApacheLuceneIndexMultiTerms () {
 @public
  IOSObjectArray *subs_;
  IOSObjectArray *subSlices_;
  jboolean hasFreqs_;
  jboolean hasOffsets_;
  jboolean hasPositions_;
  jboolean hasPayloads_;
}

@end

J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexMultiTerms, subs_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(OrgApacheLuceneIndexMultiTerms, subSlices_, IOSObjectArray *)

@implementation OrgApacheLuceneIndexMultiTerms

- (instancetype)initWithOrgApacheLuceneIndexTermsArray:(IOSObjectArray *)subs
              withOrgApacheLuceneIndexReaderSliceArray:(IOSObjectArray *)subSlices {
  OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(self, subs, subSlices);
  return self;
}

- (IOSObjectArray *)getSubTerms {
  return subs_;
}

- (IOSObjectArray *)getSubSlices {
  return subSlices_;
}

- (OrgApacheLuceneIndexTermsEnum *)intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:(OrgApacheLuceneUtilAutomatonCompiledAutomaton *)compiled
                                                              withOrgApacheLuceneUtilBytesRef:(OrgApacheLuceneUtilBytesRef *)startTerm {
  id<JavaUtilList> termsEnums = create_JavaUtilArrayList_init();
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(subs_))->size_; i++) {
    OrgApacheLuceneIndexTermsEnum *termsEnum = [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs_, i))) intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:compiled withOrgApacheLuceneUtilBytesRef:startTerm];
    if (termsEnum != nil) {
      [termsEnums addWithId:create_OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex_initWithOrgApacheLuceneIndexTermsEnum_withInt_(termsEnum, i)];
    }
  }
  if ([termsEnums size] > 0) {
    return [create_OrgApacheLuceneIndexMultiTermsEnum_initWithOrgApacheLuceneIndexReaderSliceArray_(subSlices_) resetWithOrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndexArray:[termsEnums toArrayWithNSObjectArray:JreLoadStatic(OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex, EMPTY_ARRAY)]];
  }
  else {
    return JreLoadStatic(OrgApacheLuceneIndexTermsEnum, EMPTY);
  }
}

- (OrgApacheLuceneUtilBytesRef *)getMin {
  OrgApacheLuceneUtilBytesRef *minTerm = nil;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      OrgApacheLuceneUtilBytesRef *term = JreRetainedLocalValue([((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getMin]);
      if (minTerm == nil || [((OrgApacheLuceneUtilBytesRef *) nil_chk(term)) compareToWithId:minTerm] < 0) {
        minTerm = term;
      }
    }
  }
  return minTerm;
}

- (OrgApacheLuceneUtilBytesRef *)getMax {
  OrgApacheLuceneUtilBytesRef *maxTerm = nil;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      OrgApacheLuceneUtilBytesRef *term = JreRetainedLocalValue([((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getMax]);
      if (maxTerm == nil || [((OrgApacheLuceneUtilBytesRef *) nil_chk(term)) compareToWithId:maxTerm] > 0) {
        maxTerm = term;
      }
    }
  }
  return maxTerm;
}

- (OrgApacheLuceneIndexTermsEnum *)iterator {
  id<JavaUtilList> termsEnums = create_JavaUtilArrayList_init();
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(subs_))->size_; i++) {
    OrgApacheLuceneIndexTermsEnum *termsEnum = [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs_, i))) iterator];
    if (termsEnum != nil) {
      [termsEnums addWithId:create_OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex_initWithOrgApacheLuceneIndexTermsEnum_withInt_(termsEnum, i)];
    }
  }
  if ([termsEnums size] > 0) {
    return [create_OrgApacheLuceneIndexMultiTermsEnum_initWithOrgApacheLuceneIndexReaderSliceArray_(subSlices_) resetWithOrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndexArray:[termsEnums toArrayWithNSObjectArray:JreLoadStatic(OrgApacheLuceneIndexMultiTermsEnum_TermsEnumIndex, EMPTY_ARRAY)]];
  }
  else {
    return JreLoadStatic(OrgApacheLuceneIndexTermsEnum, EMPTY);
  }
}

- (jlong)size {
  return -1;
}

- (jlong)getSumTotalTermFreq {
  jlong sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jlong v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getSumTotalTermFreq];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jlong)getSumDocFreq {
  jlong sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jlong v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getSumDocFreq];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jint)getDocCount {
  jint sum = 0;
  {
    IOSObjectArray *a__ = subs_;
    OrgApacheLuceneIndexTerms * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    OrgApacheLuceneIndexTerms * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      OrgApacheLuceneIndexTerms *terms = *b__++;
      jint v = [((OrgApacheLuceneIndexTerms *) nil_chk(terms)) getDocCount];
      if (v == -1) {
        return -1;
      }
      sum += v;
    }
  }
  return sum;
}

- (jboolean)hasFreqs {
  return hasFreqs_;
}

- (jboolean)hasOffsets {
  return hasOffsets_;
}

- (jboolean)hasPositions {
  return hasPositions_;
}

- (jboolean)hasPayloads {
  return hasPayloads_;
}

- (void)dealloc {
  RELEASE_(subs_);
  RELEASE_(subSlices_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, 1, -1, -1, -1 },
    { NULL, "[LOrgApacheLuceneIndexTerms;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[LOrgApacheLuceneIndexReaderSlice;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgApacheLuceneIndexTermsEnum;", 0x1, 2, 3, 1, -1, -1, -1 },
    { NULL, "LOrgApacheLuceneUtilBytesRef;", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "LOrgApacheLuceneUtilBytesRef;", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "LOrgApacheLuceneIndexTermsEnum;", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithOrgApacheLuceneIndexTermsArray:withOrgApacheLuceneIndexReaderSliceArray:);
  methods[1].selector = @selector(getSubTerms);
  methods[2].selector = @selector(getSubSlices);
  methods[3].selector = @selector(intersectWithOrgApacheLuceneUtilAutomatonCompiledAutomaton:withOrgApacheLuceneUtilBytesRef:);
  methods[4].selector = @selector(getMin);
  methods[5].selector = @selector(getMax);
  methods[6].selector = @selector(iterator);
  methods[7].selector = @selector(size);
  methods[8].selector = @selector(getSumTotalTermFreq);
  methods[9].selector = @selector(getSumDocFreq);
  methods[10].selector = @selector(getDocCount);
  methods[11].selector = @selector(hasFreqs);
  methods[12].selector = @selector(hasOffsets);
  methods[13].selector = @selector(hasPositions);
  methods[14].selector = @selector(hasPayloads);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "subs_", "[LOrgApacheLuceneIndexTerms;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "subSlices_", "[LOrgApacheLuceneIndexReaderSlice;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "hasFreqs_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "hasOffsets_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "hasPositions_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "hasPayloads_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "[LOrgApacheLuceneIndexTerms;[LOrgApacheLuceneIndexReaderSlice;", "LJavaIoIOException;", "intersect", "LOrgApacheLuceneUtilAutomatonCompiledAutomaton;LOrgApacheLuceneUtilBytesRef;" };
  static const J2ObjcClassInfo _OrgApacheLuceneIndexMultiTerms = { "MultiTerms", "org.apache.lucene.index", ptrTable, methods, fields, 7, 0x11, 15, 6, -1, -1, -1, -1, -1 };
  return &_OrgApacheLuceneIndexMultiTerms;
}

@end

void OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(OrgApacheLuceneIndexMultiTerms *self, IOSObjectArray *subs, IOSObjectArray *subSlices) {
  OrgApacheLuceneIndexTerms_init(self);
  JreStrongAssign(&self->subs_, subs);
  JreStrongAssign(&self->subSlices_, subSlices);
  JreAssert(((IOSObjectArray *) nil_chk(subs))->size_ > 0, @"inefficient: don't use MultiTerms over one sub");
  jboolean _hasFreqs = true;
  jboolean _hasOffsets = true;
  jboolean _hasPositions = true;
  jboolean _hasPayloads = false;
  for (jint i = 0; i < subs->size_; i++) {
    _hasFreqs &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasFreqs];
    _hasOffsets &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasOffsets];
    _hasPositions &= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasPositions];
    _hasPayloads |= [((OrgApacheLuceneIndexTerms *) nil_chk(IOSObjectArray_Get(subs, i))) hasPayloads];
  }
  self->hasFreqs_ = _hasFreqs;
  self->hasOffsets_ = _hasOffsets;
  self->hasPositions_ = _hasPositions;
  self->hasPayloads_ = (self->hasPositions_ && _hasPayloads);
}

OrgApacheLuceneIndexMultiTerms *new_OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(IOSObjectArray *subs, IOSObjectArray *subSlices) {
  J2OBJC_NEW_IMPL(OrgApacheLuceneIndexMultiTerms, initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_, subs, subSlices)
}

OrgApacheLuceneIndexMultiTerms *create_OrgApacheLuceneIndexMultiTerms_initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_(IOSObjectArray *subs, IOSObjectArray *subSlices) {
  J2OBJC_CREATE_IMPL(OrgApacheLuceneIndexMultiTerms, initWithOrgApacheLuceneIndexTermsArray_withOrgApacheLuceneIndexReaderSliceArray_, subs, subSlices)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheLuceneIndexMultiTerms)
